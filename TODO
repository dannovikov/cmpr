  ✓ clean up tmp files
  ✓ fix the build / update_symlink ergonomics
  ✓ upload to github
  ✓ support ? for keyboard help
  ✓ support c to compile
  ✓ add a license
  ✓ single keystroke to ingest new code from clipboard "R"
  ✓ links to discord/twitch/yt in repo
  ✓ triple-quoted strings
  ✓ implement "/" for search -- YES! we have search
  ✓ block ends at the next one
  ✓ the v thing because things going together
  ✓ fit the block on the screen
  ✓ parametrize the project / binary / code names, etc
    ✓ parse .cmpr/conf
    ✓ support --conf <alternate_conf_file>
      ✓ fix build
        ✓ fix or 'r' get_code
    ✓ Python or C? later: arbitrary block defn
    ✓ eventually the config will just be a block (?) but for now we'll use .cmpr in the current directory
    ✓ finish all the settings
  ✓ push v2-b1 to github
  ✓ parametrize block_comment_part same as finding the blocks
  ✓ clean up the code a bit
  ✓ use it for chess_bpa
  ✓ test it with a Python project
  ✓ push v2 to github
  ✓ add "init"
    ✓ touch .cmpr/conf
    ✓ create .cmpr/{revs,tmp}
    ✗ set those conf vars and save
  ✓ add 'g'
  ✓ add 'G' (w/o numeric args)
  ✓ genericize the arena allocation of array types
      move this back into library code
  ✓ Python crashing when only """ in block
  ✓ "library" support
    ✓ list of files in the conf, bring in blocks from each one in order
    ✓ block type is per file, not per project
    ✓ language build tool will manage dependencies, so we don't have any feature work here
  ✓ directory tree support: support projects in directories by reading everything into one buffer
  ✓ don't symlink but just copy the new version (e.g. we shouldn't be committing a symlink for the main project file in git)
  ✓ support an alternative conf file location
  ✓ handle syntax highlighting / filetype issues: put an extension the tmp filename
  ✓ push v3 to github
  ✓ decide how to handle structs / other things that aren't functions
  ✓ add "?"
  ✓ pagination
    ✓ implement space/b
  ✓ add a build timestamp to the version string
  ✓ add a Makefile
  ✓ publish TODO in the repo
  ✓ push v4
  ✓ make sure there is at least one file (in check_conf_vars)
  ✓ when the conf file doesn't exist report the error better
  ✓ push v4 again
  ✓ add JS support
    ✓ test via 2048 demo
  ✓ add 
    ✓ --print-block N
    ✓ --count-blocks
    ✓ --print-code N
    ✓ --print-comment N
    ✓ --find-block <literal>
  ✓ add :bootstrap
    ✓ try mawk manually
    ✓ local bootstrap script for cmpr itself
    ✓ system() -> send to model (currently send_to_clipboard)
  ✓ handle the multiple search result issue -- just make 'n' and 'N' work
    ✗ the search should show the current matching line, in the center of the display
    ✗ n goes to the next, which may or may not be in the same block
    ✗ enter sets the current index but can also set a pagination mode
    ✗ e might also do a +N or equivalent
  ✓ when switching blocks we should reset pagination (per-block(?))
  ✓ R should ensure that there is a newline at the end
  ✓ fix ruler position bug
  ✓ first version of bootstrap can be the first extended (ex commands) :bootstrap
  ✓ push v5
  ✓ fix --init
  ✓ 'v' by accident is annoying
  ✓ push v6
    dataloss pass: think through everything; addresses control issue
    add :tests
      tests: --init, main loop (j/k/g/G), find and print block features, Python support, [...]
    unified diff stuff
      try getting GPT4 to suggest changes to the comment part
    bug: (mkdir pytest; cd pytest; cmpr --init; cmpr # use Python language with .cmpr/conf)
    add markdown support
    put something in the README about coexistence with SCMs/git
    just create revdir and tmpdir if they don't exist
    example blocks should be in the README (maybe the arg parsing one)
    *** soft launch ***
    try more with VSCode support
    librification / cleanup
    "total rev awareness"
      start with bpe(?)
      https://en.wikipedia.org/wiki/Johnson%E2%80%93Lindenstrauss_lemma
      start by determining which revs go to which files
      is a set of features starting from an index or rolling hash
      indexed at newlines(?)
      subsumes diff features, data loss prevention on save, block -> rev indexing
      conflicts with catalog file idea (?)
    data loss when two cmprs open (related to rev currency check)
    not mint a rev if block unchanged / basic diff features "d" for diff (by def. w/ prev rev) of block
    add u for "R"
    ✓ sort the revdir and print everything
      add a catalog file in revs/catalog
      every rev gets written to it, and we parse it on startup
    might as well start with a (tabular-programmed) set of them:
      :bootstrap :addfile :addlib :help
    actually use the arena allocation to e.g. reclaim cmp space (clipboard handling, etc)
    "manual fixup" as a feature: put a "you got this wrong" in the prompt but not the block comment
      can piggyback on hashtags features
    fix bug: an empty file (e.g. index.html) block is reported belonging to prev, non-empty file
    add translations into ~every language
    publish training data?
      as separate repo
    asking for tmpdir and revdir is dumb now that we have --init; just default them
    settings mode works by opening the conf file in a buffer and syntax checking it after (visudo style)
    to "file:" we add "collection:" (library, folder, ...) which is exactly the same but adds a "dir"
      (By "dir" we mean a level of hierarchy in the UI that's closed by default.)
      (We can use "lib:" so for example "library: spanio.c" would give a neat "spanio> " in the UI.)
    add a ":addfile" or something where we repeat the question about language
    add "settings mode" but for files
    deal with the function declaration / header issue -> general-purpose code hygiene transforms
    support having "principles" that are checked/enforced by the LLM
      only on block changes for efficiency / over all code by special command
    think about using the LLM to write the comment and not just the code (i.e. 'r' and 'R')
    check if current file == latest rev on load, if not store a new rev
    support API usage
    parametrize comment_to_prompt
    make the prompts all config -- or all files in .cmpr
    editor should be a config
    add o / O for block insertions
      works the same as editing a block except the file starts empty and instead of replacing we insert
      once we show the file in the ruler, always adds to the current file
    add support for numbers (e.g. for G, d, etc)
    support "extended" commands starting with ":"
    add 'd', 'p', 'P' so that moving around blocks is easy
    visual selection mode works with "r"
    visual selection mode works with "e"
    sometimes you want to unconditionally append, not replace the code part (p? v?)
    something like "*" in vim, also "gd"
    consider metadata on blocks: prompt "wrapper" functions, custom block end, etc
    tagging blocks
    bring compiler errors into the workflow (line no -> block, etc)
      stderr into a file into a "temporary" block
      heuristics identify errors and line numbers in a compiler-agnostic way
    FIX code formatting issues once and for all
    ****** have cmpr handle it's own TODO items ******
    support system prompts / "spanio_prompt" and "code_prompt" / "bootstrap" prompt
    add to the prompt all the library methods that there are, and let it either use only those OR forward declare any additions
    think about library ergonomics around prt2cmp (belongs in a library TODO not here)
    find the right way to handle blocks (language agnostic, ...)
    TOC presentation of blocks (LLM summarization???)
    intro video -- mp4 or gif in repo -- youtube (language switch)
    basic stats on blocks e.g. comment-code ratio
    video note: we have done things (not 2048) out of training set
    issue with the exec bit on bootstrap.sh
    experiment with GPT4 finetunes
