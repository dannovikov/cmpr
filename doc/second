/*
cmpr second half:

first half is English -> traditional programming language

second half is the inverse

we start by implementing manually on the mawk repo which apt-get source wonderfully got for us
*/

//sh> (cd mawk-*; find . )

or in vim via ":r! sh -c \"(cd mawk-*; find . )\""

.
./version.c
./man
./man/Makefile.in
./man/mawk.1
./man/mawk.doc
./man/TODO
./man/array.pdf
./code.c
./init.c
./split.h
./README
./da.c
./test
./test/wfrq0.awk
./test/reg2.awk
./test/fpetest2.awk
./test/decl-awk.out
./test/wc-awk.out
./test/reg7.awk
./test/null-rs.dat
./test/fpe_test
./test/null-rs.awk
./test/nulls0.awk
./test/nextfile.out
./test/reg6.awk
./test/fpetest1.awk
./test/reg5.awk
./test/nulls.out
./test/null-rs.out
./test/mawknull.dat
./test/mawktest
./test/wc.awk
./test/reg1.awk
./test/reg-awk.out
./test/wfrq-awk.out
./test/fpetest3.awk
./test/reg4.awk
./test/fpe_test.bat
./test/mawktest.dat
./test/reg3.awk
./test/full-awk.dat
./test/reg0.awk
./test/nextfile.awk
./test/noloop.awk
./test/mawktest.bat
./makescan.c
./main.c
./field.h
./rexp2.c
./aclocal.m4
./bi_vars.c
./jmp.h
./examples
./examples/hical
./examples/qsort.awk
./examples/deps.awk
./examples/eatc.awk
./examples/ct_length.awk
./examples/primes.awk
./examples/decl.awk
./examples/nocomment.awk
./examples/hcal
./examples/gdecl.awk
./regexp_system.c
./field.c
./CHANGES
./fpe_check.c
./patchlev.h
./sizes.h
./configure.in
./configure
./INSTALL
./files.h
./Makefile.in
./memory.h
./config.guess
./array.h
./parse.h
./bi_funct.c
./files.c
./scan.h
./regexp.h
./trace.c
./scancode.h
./parse.y
./config_h.in
./install-sh
./rexp3.c
./print.c
./fcall.c
./rexpdb.c
./rexp.c
./parse.c
./split.c
./mawk.h
./bi_vars.h
./types.h
./repl.h
./zmalloc.h
./rexp.h
./rexp4.c
./COPYING
./nstd.h
./icons
./icons/mawk48.svg
./icons/mawk144.png
./icons/mawk48.png
./zmalloc.c
./rexp0.c
./ACKNOWLEDGMENT
./regexp.c
./makedeps.sh
./array.c
./matherr.c
./init.h
./kw.c
./.pc
./.pc/applied-patches
./.pc/.quilt_series
./.pc/.quilt_patches
./.pc/.version
./cast.c
./package
./package/mawk.spec
./package/debian
./package/debian/prerm
./package/debian/docs
./package/debian/copyright
./package/debian/watch
./package/debian/control
./package/debian/postrm
./package/debian/postinst
./package/debian/rules
./package/debian/changelog
./package/debian/compat
./package/debian/preinst
./package/debian/source
./package/debian/source/format
./code.h
./rexp1.c
./config.sub
./fin.c
./MANIFEST
./array.w
./bi_funct.h
./memory.c
./jmp.c
./re_cmpl.c
./error.c
./fin.h
./debian
./debian/clean
./debian/mawk.prerm
./debian/salsa-ci.yml
./debian/tests
./debian/tests/control
./debian/tests/mawktest
./debian/copyright
./debian/watch
./debian/control
./debian/mawk.dirs
./debian/rules
./debian/mawk.examples
./debian/mawk.postinst
./debian/changelog
./debian/source
./debian/source/format
./debian/mawk.docs
./debian/upstream
./debian/upstream/metadata
./vs6.mak
./scan.c
./symtype.h
./execute.c
./hash.c
./msdos
./msdos/examples
./msdos/examples/winobj.awk
./msdos/examples/texttest.awk
./msdos/examples/srcstat2.awk
./msdos/examples/add_cr.awk
./msdos/examples/objstat.awk
./msdos/examples/srcstat.awk
./msdos/examples/winexe.awk
./msdos/examples/shell.awk
./msdos/examples/doslist.awk
./msdos/dosexec.c
./msdos/vs2008.mak
./msdos/vs2008.h

//sh> (cd mawk-* ; find -type f | wc -l )

175

r! sh -c "(cd mawk-*; find -type f -exec file '{}' \; )"
./version.c: C source, ASCII text
./man/Makefile.in: makefile script, ASCII text
./man/mawk.1: troff or preprocessor input, ASCII text
./man/mawk.doc: ASCII text, with overstriking
./man/TODO: ASCII text
./man/array.pdf: PDF document, version 1.2
./code.c: C source, ASCII text
./init.c: C source, ASCII text
./split.h: C source, ASCII text
./README: ASCII text
./da.c: C source, ASCII text
./test/wfrq0.awk: awk or perl script, ASCII text
./test/reg2.awk: ASCII text
./test/fpetest2.awk: awk or perl script, ASCII text
./test/decl-awk.out: ASCII text
./test/wc-awk.out: ASCII text
./test/reg7.awk: awk or perl script, ASCII text
./test/null-rs.dat: data
./test/fpe_test: POSIX shell script, ASCII text executable
./test/null-rs.awk: awk or perl script, ASCII text
./test/nulls0.awk: ASCII text
./test/nextfile.out: ASCII text
./test/reg6.awk: awk or perl script, ASCII text
./test/fpetest1.awk: awk or perl script, ASCII text
./test/reg5.awk: awk or perl script, ASCII text
./test/nulls.out: ASCII text
./test/null-rs.out: ASCII text
./test/mawknull.dat: data
./test/mawktest: POSIX shell script, ASCII text executable
./test/wc.awk: ASCII text
./test/reg1.awk: ASCII text
./test/reg-awk.out: ASCII text
./test/wfrq-awk.out: ASCII text
./test/fpetest3.awk: awk or perl script, ASCII text
./test/reg4.awk: ASCII text
./test/fpe_test.bat: ASCII text
./test/mawktest.dat: C source, ASCII text
./test/reg3.awk: awk or perl script, ASCII text
./test/full-awk.dat: ASCII text
./test/reg0.awk: ASCII text
./test/nextfile.awk: ASCII text
./test/noloop.awk: ASCII text
./test/mawktest.bat: DOS batch file, ASCII text
./makescan.c: C source, ASCII text
./main.c: C source, ASCII text
./field.h: C source, ASCII text
./rexp2.c: C source, ASCII text
./aclocal.m4: M4 macro processor script, ASCII text
./bi_vars.c: C source, ASCII text
./jmp.h: C source, ASCII text
./examples/hical: POSIX shell script, ASCII text executable
./examples/qsort.awk: awk or perl script, ASCII text
./examples/deps.awk: awk or perl script, ASCII text
./examples/eatc.awk: a /usr/bin/mawk -f script, ASCII text executable
./examples/ct_length.awk: a /usr/bin/mawk -f script, ASCII text executable
./examples/primes.awk: awk or perl script, ASCII text
./examples/decl.awk: awk script, ASCII text executable
./examples/nocomment.awk: awk or perl script, ASCII text
./examples/hcal: awk or perl script, ASCII text
./examples/gdecl.awk: awk or perl script, ASCII text
./regexp_system.c: C source, ASCII text
./field.c: C source, ASCII text
./CHANGES: ASCII text
./fpe_check.c: C source, ASCII text
./patchlev.h: ASCII text
./sizes.h: C source, ASCII text
./configure.in: M4 macro processor script, ASCII text
./configure: POSIX shell script, ASCII text executable
./INSTALL: ASCII text
./files.h: C source, ASCII text
./Makefile.in: makefile script, ASCII text
./memory.h: C source, ASCII text
./config.guess: POSIX shell script, ASCII text executable
./array.h: C source, ASCII text
./parse.h: C source, ASCII text
./bi_funct.c: C source, ASCII text
./files.c: C source, ASCII text
./scan.h: C source, ASCII text
./regexp.h: C source, ASCII text
./trace.c: C source, ASCII text
./scancode.h: C source, ASCII text
./parse.y: C source, ASCII text
./config_h.in: C source, ASCII text
./install-sh: POSIX shell script, ASCII text executable
./rexp3.c: C source, ASCII text
./print.c: C source, ASCII text
./fcall.c: C source, ASCII text
./rexpdb.c: C source, ASCII text
./rexp.c: C source, ASCII text
./parse.c: C source, ASCII text
./split.c: C source, ASCII text
./mawk.h: C source, ASCII text
./bi_vars.h: C source, ASCII text
./types.h: C source, ASCII text
./repl.h: C source, ASCII text
./zmalloc.h: C source, ASCII text
./rexp.h: C source, ASCII text
./rexp4.c: C source, ASCII text
./COPYING: ASCII text
./nstd.h: C source, ASCII text
./icons/mawk48.svg: SVG Scalable Vector Graphics image
./icons/mawk144.png: PNG image data, 144 x 144, 8-bit/color RGBA, non-interlaced
./icons/mawk48.png: PNG image data, 48 x 48, 8-bit/color RGBA, non-interlaced
./zmalloc.c: C source, ASCII text
./rexp0.c: C source, ASCII text
./ACKNOWLEDGMENT: ASCII text
./regexp.c: C source, ASCII text
./makedeps.sh: POSIX shell script, ASCII text executable
./array.c: C source, ASCII text
./matherr.c: C source, ASCII text
./init.h: C source, ASCII text
./kw.c: C source, ASCII text
./.pc/applied-patches: empty
./.pc/.quilt_series: ASCII text
./.pc/.quilt_patches: ASCII text
./.pc/.version: ASCII text
./cast.c: C source, ASCII text
./package/mawk.spec: ASCII text
./package/debian/prerm: POSIX shell script, ASCII text executable
./package/debian/docs: ASCII text
./package/debian/copyright: ASCII text
./package/debian/watch: ASCII text
./package/debian/control: ASCII text
./package/debian/postrm: POSIX shell script, ASCII text executable
./package/debian/postinst: POSIX shell script, ASCII text executable
./package/debian/rules: makefile script, ASCII text
./package/debian/changelog: ASCII text
./package/debian/compat: ASCII text
./package/debian/preinst: POSIX shell script, ASCII text executable
./package/debian/source/format: ASCII text
./code.h: C source, ASCII text
./rexp1.c: C source, ASCII text
./config.sub: POSIX shell script, ASCII text executable
./fin.c: C source, ASCII text
./MANIFEST: ASCII text
./array.w: LaTeX document, ASCII text
./bi_funct.h: C source, ASCII text
./memory.c: C source, ASCII text
./jmp.c: C source, ASCII text
./re_cmpl.c: C source, ASCII text
./error.c: C source, ASCII text
./fin.h: C source, ASCII text
./debian/clean: ASCII text
./debian/mawk.prerm: POSIX shell script, ASCII text executable
./debian/salsa-ci.yml: ASCII text
./debian/tests/control: ASCII text
./debian/tests/mawktest: POSIX shell script, ASCII text executable
./debian/copyright: UTF-8 Unicode text
./debian/watch: ASCII text
./debian/control: ASCII text
./debian/mawk.dirs: ASCII text
./debian/rules: a /usr/bin/make -f script, ASCII text executable
./debian/mawk.examples: ASCII text
./debian/mawk.postinst: POSIX shell script, ASCII text executable
./debian/changelog: ASCII text
./debian/source/format: ASCII text
./debian/mawk.docs: ASCII text
./debian/upstream/metadata: ASCII text
./vs6.mak: makefile script, ASCII text, with CRLF line terminators
./scan.c: C source, ASCII text
./symtype.h: C source, ASCII text
./execute.c: C source, ASCII text
./hash.c: C source, ASCII text
./msdos/examples/winobj.awk: awk or perl script, ASCII text
./msdos/examples/texttest.awk: ASCII text
./msdos/examples/srcstat2.awk: awk or perl script, ASCII text
./msdos/examples/add_cr.awk: awk or perl script, ASCII text
./msdos/examples/objstat.awk: awk or perl script, ASCII text
./msdos/examples/srcstat.awk: awk or perl script, ASCII text
./msdos/examples/winexe.awk: awk or perl script, ASCII text
./msdos/examples/shell.awk: awk or perl script, ASCII text
./msdos/examples/doslist.awk: ASCII text
./msdos/dosexec.c: C source, ASCII text
./msdos/vs2008.mak: makefile script, ASCII text, with CRLF line terminators
./msdos/vs2008.h: C source, ASCII text

I will now choose to start from main.c.


/********************************************
main.c
copyright 2009-2014,2017 Thomas E. Dickey
copyright 1991-1995,2014, Michael D. Brennan

This is a source file for mawk, an implementation of
the AWK programming language.

Mawk is distributed without warranty under the terms of
the GNU General Public License, version 2, 1991.
********************************************/

/*
 * $MawkId: main.c,v 1.31 2017/10/17 00:41:48 tom Exp $
 */

/*  main.c  */

#include "mawk.h"
#include "bi_vars.h"
#include "init.h"
#include "code.h"
#include "files.h"

#ifdef LOCALE
#include <locale.h>
#endif

short mawk_state;		/* 0 is compiling */
int exit_code;

#if defined(__GNUC__) && defined(_FORTIFY_SOURCE)
int ignore_unused;
#endif

#ifdef LOCALE
char decimal_dot;
#endif

int
main(int argc, char **argv)
{
#ifdef LOCALE
    setlocale(LC_CTYPE, "");
    setlocale(LC_NUMERIC, "C");
#endif
    initialize(argc, argv);
#ifdef LOCALE
    {
	struct lconv *data;

	decimal_dot = '\0';	/* only set to nonzero if not POSIX '.' */
	setlocale(LC_NUMERIC, "");
	data = localeconv();
	if (data != 0
	    && data->decimal_point != 0
	    && strlen(data->decimal_point) == 1) {
	    decimal_dot = data->decimal_point[0];
	} else {
	    /* back out of this if we cannot handle it */
	    setlocale(LC_NUMERIC, "C");
	}
	if (decimal_dot == '.')
	    decimal_dot = 0;
    }
#endif

    parse();

    mawk_state = EXECUTION;
    execute(execution_start, eval_stack - 1, 0);
    /* never returns */
    return 0;
}

void
mawk_exit(int x)
{
#ifdef  HAVE_REAL_PIPES
    close_out_pipes();		/* actually closes all output */
#else
#ifdef  HAVE_FAKE_PIPES
    close_fake_pipes();
#endif
#endif

#ifdef NO_LEAKS
    code_leaks();
    scan_leaks();
    cell_leaks();
    re_leaks();
    rexp_leaks();
    bi_vars_leaks();
    hash_leaks();
    array_leaks();
    files_leaks();
    fin_leaks();
    field_leaks();
    zmalloc_leaks();
#if OPT_TRACE > 0
    trace_leaks();
#endif
#endif

    exit(x);
}

/* after main.c */

So main calls initialize(), then parse(), then execute().
This should be the main part of the program to understand.

I think if I actually want to do this manually, I'd start by putting main() in a block, with initialize(), parse() and execute(), and then I'd go look up those three functions.

So I'd start by simplifying but also recreating the dependency graph upside down.



I also want to point out the importance of the order of the blocks to the human reader.
This has implications about how we can compress the information.

So this is what I want to read:

- three function signatures and some types (init, parse, exec and their arg/return types).
- the implementation of main() in these terms
- the implementation of initialize(), since it was the first called, following the same pattern:
  - function signatures of anything initialize calls
  - the function itself
  - but we are breadth-first so we don't recurse into the implementations of init's callees yet
- the implementation of parse in the same terms
- execute() in the same terms
- then the first callee of initialize, since that will now be the first undefined thing
  - anything that it calls can be thought of as getting "enqueued"
  - The queue is just the sequence in the document between the last call that we've had to chase the last function that we implemented of all the callees not yet defined.

This makes library boundaries somewhat important.
For example, if spanio is part of the code, it becomes clear that we don't want prt coming after main just because the first call to prt was in main.

The order of the blocks can be picked by the human for now.

So now what I want to do is start putting all the functions into blocks.

I'm going to start with ctags actually.

The idea is this:

There's currently the wrong number of blocks.

The idea is that we leave all of mawk where it is, but we start building our own dependency chart, as blocks.

The sequence of these blocks might as well occur in a file, say .cmpr/depgraph.

First I just want to see what ctags gives me.

Some interesting details:

:r! ctags --list-maps

Ant      *.build.xml
Asm      *.asm *.ASM *.s *.S *.A51 *.29[kK] *.[68][68][kKsSxX] *.[xX][68][68]
Asp      *.asp *.asa
Awk      *.awk *.gawk *.mawk
Basic    *.bas *.bi *.bb *.pb
BETA     *.bet
C        *.c
C++      *.c++ *.cc *.cp *.cpp *.cxx *.h *.h++ *.hh *.hp *.hpp *.hxx *.C *.H
C#       *.cs
Cobol    *.cbl *.cob *.CBL *.COB
DosBatch *.bat *.cmd
Eiffel   *.e
Erlang   *.erl *.ERL *.hrl *.HRL
Flex     *.as *.mxml
Fortran  *.f *.for *.ftn *.f77 *.f90 *.f95 *.F *.FOR *.FTN *.F77 *.F90 *.F95
Go       *.go
HTML     *.htm *.html
Java     *.java
JavaScript *.js
Lisp     *.cl *.clisp *.el *.l *.lisp *.lsp
Lua      *.lua
Make     *.mak *.mk [Mm]akefile GNUmakefile
MatLab   *.m
ObjectiveC *.m *.h
OCaml    *.ml *.mli
Pascal   *.p *.pas
Perl     *.pl *.pm *.plx *.perl
PHP      *.php *.php3 *.phtml
Python   *.py *.pyx *.pxd *.pxi *.scons
REXX     *.cmd *.rexx *.rx
Ruby     *.rb *.ruby
Scheme   *.SCM *.SM *.sch *.scheme *.scm *.sm
Sh       *.sh *.SH *.bsh *.bash *.ksh *.zsh
SLang    *.sl
SML      *.sml *.sig
SQL      *.sql
Tcl      *.tcl *.tk *.wish *.itcl
Tex      *.tex
Vera     *.vr *.vri *.vrh
Verilog  *.v
VHDL     *.vhdl *.vhd
Vim      *.vim
YACC     *.y

:r! ctags --list-languages
Ant
Asm
Asp
Awk
Basic
BETA
C
C++
C#
Cobol
DosBatch
Eiffel
Erlang
Flex
Fortran
Go
HTML
Java
JavaScript
Lisp
Lua
Make
MatLab
ObjectiveC
OCaml
Pascal
Perl
PHP
Python
REXX
Ruby
Scheme
Sh
SLang
SML
SQL
Tcl
Tex
Vera
Verilog
VHDL
Vim
YACC

/* actual ctags output

r! sh -c "(cd mawk-*; ctags -R; cat tags)"

*/


!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_PROGRAM_AUTHOR	Darren Hiebert	/dhiebert@users.sourceforge.net/
!_TAG_PROGRAM_NAME	Exuberant Ctags	//
!_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
!_TAG_PROGRAM_VERSION	5.9~svn20110310	//
A	bi_funct.c	733;"	d	file:
A	bi_funct.c	852;"	d	file:
ACTION	execute.c	1188;"	d	file:
ADD_ASG	parse.c	135;"	d	file:
ADD_ASG	parse.h	12;"	d
AE_PUSHA	code.h	/^    ,AE_PUSHA$/;"	e	enum:__anon24
AE_PUSHI	code.h	/^    ,AE_PUSHI$/;"	e	enum:__anon24
ALL_ARRAYS	init.c	/^} ALL_ARRAYS;$/;"	t	typeref:struct:_all_arrays	file:
ALL_CELLS	cast.c	/^} ALL_CELLS;$/;"	t	typeref:struct:_all_cells	file:
ALL_PTRS	re_cmpl.c	/^} ALL_PTRS;$/;"	t	typeref:struct:_all_ptrs	file:
ALOOP	code.h	/^    ,ALOOP$/;"	e	enum:__anon24
ALOOP_STATE	execute.c	/^} ALOOP_STATE;$/;"	t	typeref:struct:aloop_state	file:
AND	parse.c	144;"	d	file:
AND	parse.h	21;"	d
ANODE	array.c	/^} ANODE ;$/;"	t	typeref:struct:anode	file:
ARG2_REC	symtype.h	/^} ARG2_REC;$/;"	t	typeref:struct:__anon27
ARGC	bi_vars.h	42;"	d
ARRAY	array.h	/^} *ARRAY ;$/;"	t	typeref:struct:array
ARRAY_H	array.h	26;"	d
ASSIGN	parse.c	134;"	d	file:
ASSIGN	parse.h	11;"	d
AST	print.c	142;"	d	file:
AT_LAST	regexp_system.c	33;"	d	file:
AY_INT	array.h	39;"	d
AY_NULL	array.h	38;"	d
AY_SPLIT	array.h	41;"	d
AY_STR	array.h	40;"	d
A_CAT	code.h	/^    ,A_CAT$/;"	e	enum:__anon24
A_DEL	code.h	/^    ,A_DEL$/;"	e	enum:__anon24
A_HASH_PRIME	sizes.h	81;"	d
A_LENGTH	code.h	/^    ,A_LENGTH$/;"	e	enum:__anon24
A_PUSHA	code.h	/^    ,A_PUSHA$/;"	e	enum:__anon24
A_TEST	code.h	/^    ,A_TEST$/;"	e	enum:__anon24
AddDeps	makedeps.sh	/^function AddDeps() {$/;"	f
Argv	fin.c	/^ARRAY Argv;			\/* to the user this is ARGV  *\/$/;"	v
BAD_DECIMAL	parse.c	125;"	d	file:
BAD_DECIMAL	parse.h	2;"	d
BC	jmp.c	/^} BC;$/;"	t	typeref:struct:bc	file:
BC_clear	jmp.c	/^BC_clear(INST * B_address, INST * C_address)$/;"	f
BC_insert	jmp.c	/^BC_insert(int type, INST * address)$/;"	f
BC_new	jmp.c	/^BC_new(void)			\/* mark the start of a loop *\/$/;"	f
BEGIN	parse.c	192;"	d	file:
BEGIN	parse.h	69;"	d
BINMODE	bi_vars.h	51;"	d
BI_FUNCT_H	bi_funct.h	18;"	d
BI_REC	symtype.h	/^} BI_REC;$/;"	t	typeref:struct:__anon26
BI_VARS_H	bi_vars.h	30;"	d
BREAK	parse.c	187;"	d	file:
BREAK	parse.h	64;"	d
BUFFSZ	sizes.h	68;"	d
BUFFSZ	sizes.h	74;"	d
BUFFSZ	sizes.h	75;"	d
BUILTIN	parse.c	176;"	d	file:
BUILTIN	parse.h	53;"	d
BV	rexp.h	/^typedef UChar BV[32];		\/* bit vector *\/$/;"	t
BV_GROWTH	rexp0.c	705;"	d	file:
Begin	test/mawktest	/^Begin() {$/;"	f
BinMode2	files.c	104;"	d	file:
BinMode2	files.c	106;"	d	file:
BlocksToBytes	zmalloc.c	33;"	d	file:
BytesToBlocks	zmalloc.c	32;"	d	file:
CASE	rexp.c	58;"	d	file:
CASE	rexp.c	80;"	d	file:
CASE_UANY	rexp2.c	158;"	d	file:
CASE_UANY	rexp3.c	33;"	d	file:
CAT	parse.c	153;"	d	file:
CAT	parse.h	30;"	d
CA_ARRAY	symtype.h	122;"	d
CA_EXPR	symtype.h	121;"	d
CA_REC	symtype.h	/^} CA_REC;			\/* call argument record *\/$/;"	t	typeref:struct:ca_rec
CCLASS	rexp0.c	/^} CCLASS;$/;"	t	typeref:struct:__anon20	file:
CCLASS_DATA	rexp0.c	332;"	d	file:
CCLASS_ENUM	rexp0.c	/^} CCLASS_ENUM;$/;"	t	typeref:enum:__anon21	file:
CCLASS_NONE	rexp0.c	/^    CCLASS_NONE = 0,$/;"	e	enum:__anon21	file:
CCLASS_alnum	rexp0.c	/^    CCLASS_alnum,$/;"	e	enum:__anon21	file:
CCLASS_alpha	rexp0.c	/^    CCLASS_alpha,$/;"	e	enum:__anon21	file:
CCLASS_blank	rexp0.c	/^    CCLASS_blank,$/;"	e	enum:__anon21	file:
CCLASS_cntrl	rexp0.c	/^    CCLASS_cntrl,$/;"	e	enum:__anon21	file:
CCLASS_digit	rexp0.c	/^    CCLASS_digit,$/;"	e	enum:__anon21	file:
CCLASS_graph	rexp0.c	/^    CCLASS_graph,$/;"	e	enum:__anon21	file:
CCLASS_lower	rexp0.c	/^    CCLASS_lower,$/;"	e	enum:__anon21	file:
CCLASS_print	rexp0.c	/^    CCLASS_print,$/;"	e	enum:__anon21	file:
CCLASS_punct	rexp0.c	/^    CCLASS_punct,$/;"	e	enum:__anon21	file:
CCLASS_space	rexp0.c	/^    CCLASS_space,$/;"	e	enum:__anon21	file:
CCLASS_upper	rexp0.c	/^    CCLASS_upper,$/;"	e	enum:__anon21	file:
CCLASS_xdigit	rexp0.c	/^    CCLASS_xdigit$/;"	e	enum:__anon21	file:
CDP	parse.c	58;"	d	file:
CELL	types.h	/^} CELL;$/;"	t	typeref:struct:cell
CFLAGS	msdos/vs2008.mak	/^CFLAGS = -I. -D_POSIX_ -DWINVER=0x501 -DLOCAL_REGEXP $(cflags)$/;"	m
CFLAGS	package/debian/rules	/^	CFLAGS="$(CFLAGS)" \\$/;"	m
CFLAGS	package/debian/rules	/^CFLAGS   = $(shell dpkg-buildflags --get CFLAGS)$/;"	m
CFLAGS	vs6.mak	/^CFLAGS = -I. -DLOCAL_REGEXP $(cflags)$/;"	m
CHECK_DIVZERO	execute.c	36;"	d	file:
CHUNK	zmalloc.c	49;"	d	file:
CLEAR_ALOOP_STACK	execute.c	74;"	d	file:
CLOSE_ON_EXEC	files.c	38;"	d	file:
CLOSE_ON_EXEC	files.c	41;"	d	file:
CMP	test/mawktest.bat	/^	if %CMP%.==. set CMP=cmp$/;"	v
CODEBLOCK	code.h	/^} CODEBLOCK;$/;"	t	typeref:struct:__anon23
CODEWARN	code.h	26;"	d
CODE_FE_PUSHA	parse.c	65;"	d	file:
COLON	parse.c	142;"	d	file:
COLON	parse.h	19;"	d
COMMA	parse.c	132;"	d	file:
COMMA	parse.h	9;"	d
CONFIG_H	msdos/vs2008.h	19;"	d
CONTINUE	parse.c	188;"	d	file:
CONTINUE	parse.h	65;"	d
CONVFMT	field.h	61;"	d
CONVFMT	field.h	77;"	d
CONVFMT_field	field.h	70;"	d
CPPFLAGS	package/debian/rules	/^CPPFLAGS = $(shell dpkg-buildflags --get CPPFLAGS)$/;"	m
CREATE	array.h	43;"	d
CXXFLAGS	package/debian/rules	/^CXXFLAGS = $(shell dpkg-buildflags --get CXXFLAGS)$/;"	m
C_DOUBLE	types.h	/^    ,C_DOUBLE$/;"	e	enum:__anon11
C_MBSTRN	types.h	/^    ,C_MBSTRN			\/*could be STRNUM, has not been checked *\/$/;"	e	enum:__anon11
C_NOINIT	types.h	/^    C_NOINIT$/;"	e	enum:__anon11
C_RE	types.h	/^    ,C_RE$/;"	e	enum:__anon11
C_REPL	types.h	/^    ,C_REPL			\/* a replacement string   '\\&' changed to &  *\/$/;"	e	enum:__anon11
C_REPLV	types.h	/^    ,C_REPLV			\/* a vector replacement -- broken on &  *\/$/;"	e	enum:__anon11
C_SNULL	types.h	/^    ,C_SNULL			\/* split on the empty string  *\/$/;"	e	enum:__anon11
C_SPACE	types.h	/^    ,C_SPACE			\/* split on space *\/$/;"	e	enum:__anon11
C_STRING	types.h	/^    ,C_STRING$/;"	e	enum:__anon11
C_STRNUM	types.h	/^    ,C_STRNUM$/;"	e	enum:__anon11
CheckStringSize	scan.c	72;"	d	file:
Chk_Date	examples/hcal	/^function Chk_Date(date) {$/;"	f
CodeOffset	code.h	47;"	d
DANGER	execute.c	43;"	d	file:
DATA	init.c	241;"	d	file:
DATA	init.c	260;"	d	file:
DATA2	init.c	242;"	d	file:
DATE_STRING	patchlev.h	19;"	d
DB_cell_destroy	execute.c	/^DB_cell_destroy(CELL *cp)$/;"	f
DB_free_STRING	memory.c	/^DB_free_STRING(STRING * sval)$/;"	f
DEBUG_ZMALLOC	zmalloc.c	67;"	d	file:
DEB_BUILD_GNU_TYPE	package/debian/rules	/^DEB_BUILD_GNU_TYPE  ?= $(shell dpkg-architecture -qDEB_BUILD_GNU_TYPE)$/;"	m
DEB_BUILD_MAINT_OPTIONS	debian/rules	/^export DEB_BUILD_MAINT_OPTIONS = hardening=+all$/;"	m
DEB_HOST_GNU_TYPE	package/debian/rules	/^DEB_HOST_GNU_TYPE   ?= $(shell dpkg-architecture -qDEB_HOST_GNU_TYPE)$/;"	m
DEB_LDFLAGS_MAINT_APPEND	debian/rules	/^export DEB_LDFLAGS_MAINT_APPEND = -Wl,--as-needed$/;"	m
DELETE	parse.c	191;"	d	file:
DELETE	parse.h	68;"	d
DEL_A	code.h	/^    ,DEL_A$/;"	e	enum:__anon24
DIV	parse.c	158;"	d	file:
DIV	parse.h	35;"	d
DIV_ASG	parse.c	138;"	d	file:
DIV_ASG	parse.h	15;"	d
DO	parse.c	184;"	d	file:
DO	parse.h	61;"	d
DOLLAR	parse.c	166;"	d	file:
DOLLAR	parse.h	43;"	d
DOSexec	msdos/dosexec.c	/^DOSexec(char *command)$/;"	f
DOUBLE	parse.c	170;"	d	file:
DOUBLE	parse.h	47;"	d
DOUBLE_AND_MBSTRN	types.h	56;"	d
DOUBLE_AND_STRING	types.h	52;"	d
DOUBLE_AND_STRNUM	types.h	53;"	d
DUAL_LINK	array.c	/^typedef struct {struct anode *slink, *ilink ;} DUAL_LINK ;$/;"	t	typeref:struct:__anon22	file:
DUMP_FUNCS	da.c	/^} DUMP_FUNCS;$/;"	t	typeref:struct:fdump	file:
DUMP_REGEX	da.c	/^} DUMP_REGEX;$/;"	t	typeref:struct:regex	file:
D_ID	parse.c	174;"	d	file:
D_ID	parse.h	51;"	d
E1	rexp.h	95;"	d
E2	rexp.h	96;"	d
E3	rexp.h	97;"	d
E4	rexp.h	98;"	d
E5	rexp.h	99;"	d
E6	rexp.h	100;"	d
E7	rexp.h	101;"	d
ELSE	parse.c	190;"	d	file:
ELSE	parse.h	67;"	d
END	parse.c	193;"	d	file:
END	parse.h	70;"	d
END_OFF	rexp.h	52;"	d
END_ON	rexp.h	53;"	d
EOF_FLAG	fin.h	47;"	d
EQ	parse.c	147;"	d	file:
EQ	parse.h	24;"	d
EQ	rexp.h	93;"	d
EVAL_STACK_SIZE	sizes.h	53;"	d
EXECUTION	mawk.h	93;"	d
EXIT	parse.c	194;"	d	file:
EXIT	parse.h	71;"	d
FBANKV_CHUNK_SIZE	field.c	36;"	d	file:
FBANK_SZ	sizes.h	59;"	d
FBLOCK	symtype.h	/^} FBLOCK;			\/* function block *\/$/;"	t	typeref:struct:fblock
FB_SHIFT	sizes.h	60;"	d
FCALL_REC	symtype.h	/^} FCALL_REC;$/;"	t	typeref:struct:fcall
FE_PUSHA	code.h	/^    FE_PUSHA = 0$/;"	e	enum:__anon24
FE_PUSHI	code.h	/^    ,FE_PUSHI$/;"	e	enum:__anon24
FIELD	parse.c	167;"	d	file:
FIELD	parse.h	44;"	d
FILENAME	bi_vars.h	43;"	d
FILE_NODE	files.c	/^} FILE_NODE;$/;"	t	typeref:struct:file	file:
FIN	fin.h	/^} FIN;$/;"	t	typeref:struct:__anon25
FIN_FLAG	fin.h	49;"	d
FIN_H	fin.h	30;"	d
FINclose	fin.c	/^FINclose(FIN * fin)$/;"	f
FINdopen	fin.c	/^FINdopen(int fd, int main_flag)$/;"	f
FINgets	fin.c	/^FINgets(FIN * fin, size_t *len_p)$/;"	f
FINopen	fin.c	/^FINopen(char *filename, int main_flag)$/;"	f
FINsemi_close	fin.c	/^FINsemi_close(FIN * fin)$/;"	f
FLAG	execute.c	1186;"	d	file:
FMT	print.c	649;"	d	file:
FMT	print.c	677;"	d	file:
FMT_N	version.c	26;"	d	file:
FMT_S	version.c	27;"	d	file:
FNR	bi_vars.h	41;"	d
FOLLOW	execute.c	1189;"	d	file:
FOR	parse.c	186;"	d	file:
FOR	parse.h	63;"	d
FPE_ARGS	fpe_check.c	53;"	d	file:
FPE_ARGS	fpe_check.c	56;"	d	file:
FPE_ARGS	matherr.c	52;"	d	file:
FPE_ARGS	matherr.c	55;"	d	file:
FPE_DECL	fpe_check.c	54;"	d	file:
FPE_DECL	fpe_check.c	57;"	d	file:
FPE_DECL	matherr.c	53;"	d	file:
FPE_DECL	matherr.c	56;"	d	file:
FPE_FLTDIV	matherr.c	86;"	d	file:
FPE_FLTOVF	matherr.c	87;"	d	file:
FPE_FLTUND	matherr.c	88;"	d	file:
FPE_UNDERFLOW	matherr.c	77;"	d	file:
FS	field.h	60;"	d
FS	field.h	76;"	d
FS_field	field.h	69;"	d
FUNCTION	parse.c	198;"	d	file:
FUNCTION	parse.h	75;"	d
FUNCT_ID	parse.c	175;"	d	file:
FUNCT_ID	parse.h	52;"	d
F_ADD_ASG	code.h	/^    ,F_ADD_ASG$/;"	e	enum:__anon24
F_APPEND	files.h	27;"	d
F_ASSIGN	code.h	/^    ,F_ASSIGN$/;"	e	enum:__anon24
F_DIV_ASG	code.h	/^    ,F_DIV_ASG$/;"	e	enum:__anon24
F_IN	files.h	24;"	d
F_MOD_ASG	code.h	/^    ,F_MOD_ASG$/;"	e	enum:__anon24
F_MUL_ASG	code.h	/^    ,F_MUL_ASG$/;"	e	enum:__anon24
F_POST_DEC	code.h	/^    ,F_POST_DEC$/;"	e	enum:__anon24
F_POST_INC	code.h	/^    ,F_POST_INC$/;"	e	enum:__anon24
F_POW_ASG	code.h	/^    ,F_POW_ASG$/;"	e	enum:__anon24
F_PRE_DEC	code.h	/^    ,F_PRE_DEC$/;"	e	enum:__anon24
F_PRE_INC	code.h	/^    ,F_PRE_INC$/;"	e	enum:__anon24
F_PUSHA	code.h	/^    ,F_PUSHA$/;"	e	enum:__anon24
F_PUSHI	code.h	/^    ,F_PUSHI$/;"	e	enum:__anon24
F_SUB_ASG	code.h	/^    ,F_SUB_ASG$/;"	e	enum:__anon24
F_TRUNC	files.h	28;"	d
Fail	test/mawktest	/^Fail() {$/;"	f
Finish	test/mawktest	/^Finish() {$/;"	f
FinishPtr	zmalloc.c	185;"	d	file:
FinishPtr	zmalloc.c	188;"	d	file:
Fmt_Date	examples/hcal	/^function Fmt_Date(date) {$/;"	f
G	rexp.h	94;"	d
GCC_NORETURN	mawk.h	36;"	d
GCC_NORETURN	rexp.h	135;"	d
GCC_PRINTFLIKE	mawk.h	40;"	d
GCC_UNUSED	mawk.h	44;"	d
GETLINE	parse.c	154;"	d	file:
GETLINE	parse.h	31;"	d
GSUB	parse.c	183;"	d	file:
GSUB	parse.h	60;"	d
GT	parse.c	151;"	d	file:
GT	parse.h	28;"	d
GTE	parse.c	152;"	d	file:
GTE	parse.h	29;"	d
Get_Date	examples/hcal	/^function Get_Date(n,m,d,y,j) {$/;"	f
Get_J	examples/hcal	/^function Get_J(m,d,y) {$/;"	f
Get_Mnum	examples/hcal	/^function Get_Mnum() {$/;"	f
Get_Now	examples/hcal	/^function Get_Now() {$/;"	f
Get_Num	examples/hcal	/^function Get_Num(date,m,d,y,j) {$/;"	f
Get_Y1	examples/hcal	/^function Get_Y1() {$/;"	f
HASHNODE	hash.c	/^} HASHNODE;$/;"	t	typeref:struct:hash	file:
HASH_PRIME	sizes.h	80;"	d
HAVE_FAKE_PIPES	msdos/vs2008.h	27;"	d
HAVE_FCNTL_H	msdos/vs2008.h	21;"	d
ID	parse.c	173;"	d	file:
ID	parse.h	50;"	d
IF	parse.c	189;"	d	file:
IF	parse.h	66;"	d
IGNORE_RC	mawk.h	48;"	d
IGNORE_RC	mawk.h	51;"	d
IN	parse.c	145;"	d	file:
IN	parse.h	22;"	d
INC_or_DEC	parse.c	165;"	d	file:
INC_or_DEC	parse.h	42;"	d
INFNAN	matherr.c	257;"	d	file:
INIT_H	init.h	20;"	d
INST	types.h	/^} INST;$/;"	t	typeref:union:__anon13
INST_BYTES	code.h	55;"	d
INT_FMT	sizes.h	33;"	d
INT_FMT	sizes.h	37;"	d
IO_IN	parse.c	162;"	d	file:
IO_IN	parse.h	39;"	d
IO_OUT	parse.c	133;"	d	file:
IO_OUT	parse.h	10;"	d
IS_OUTPUT	files.h	29;"	d
IgnoreEscaped	regexp_system.c	39;"	d	file:
IgnoreNull	regexp_system.c	38;"	d	file:
Int	sizes.h	/^typedef int Int;$/;"	t
Int	sizes.h	/^typedef long Int;$/;"	t
IsPoolable	zmalloc.c	71;"	d	file:
IsPoolable	zmalloc.c	74;"	d	file:
JMP	jmp.c	/^} JMP;$/;"	t	typeref:struct:jmp	file:
Kludge_1752	examples/hcal	/^function Kludge_1752() {$/;"	f
L	rexp.h	92;"	d
LAE_PUSHA	code.h	/^    ,LAE_PUSHA$/;"	e	enum:__anon24
LAE_PUSHI	code.h	/^    ,LAE_PUSHI$/;"	e	enum:__anon24
LAST_PFIELD	field.h	80;"	d
LA_PUSHA	code.h	/^    ,LA_PUSHA$/;"	e	enum:__anon24
LBOX	parse.c	130;"	d	file:
LBOX	parse.h	7;"	d
LBRACE	parse.c	128;"	d	file:
LBRACE	parse.h	5;"	d
LDFLAGS	package/debian/rules	/^LDFLAGS  = $(shell dpkg-buildflags --get LDFLAGS)$/;"	m
LENGTH	parse.c	177;"	d	file:
LENGTH	parse.h	54;"	d
LIMITED	regexp_system.c	36;"	d	file:
LOCAL_REGEXP	rexp0.c	20;"	d	file:
LPAREN	parse.c	168;"	d	file:
LPAREN	parse.h	45;"	d
LT	parse.c	149;"	d	file:
LT	parse.h	26;"	d
LTE	parse.c	150;"	d	file:
LTE	parse.h	27;"	d
L_PUSHA	code.h	/^    ,L_PUSHA$/;"	e	enum:__anon24
L_PUSHI	code.h	/^    ,L_PUSHI$/;"	e	enum:__anon24
Leap	examples/hcal	/^function Leap(YR) {$/;"	f
M	bi_funct.c	731;"	d	file:
M	bi_funct.c	853;"	d	file:
MACHINE	rexp.h	/^} MACHINE;$/;"	t	typeref:struct:__anon16
MAIN_FLAG	fin.h	46;"	d
MATCH	parse.c	146;"	d	file:
MATCH	parse.h	23;"	d
MATCH_FUNC	parse.c	181;"	d	file:
MATCH_FUNC	parse.h	58;"	d
MAWKBINMODE	test/mawktest.bat	/^	set MAWKBINMODE=7$/;"	v
MAWK_CELL_TYPES	types.h	/^} MAWK_CELL_TYPES;$/;"	t	typeref:enum:__anon11
MAWK_CODE_H	code.h	20;"	d
MAWK_FIELD_H	field.h	33;"	d
MAWK_FILES_H	files.h	18;"	d
MAWK_H	mawk.h	20;"	d
MAWK_JMP_H	jmp.h	31;"	d
MAWK_MEMORY_H	memory.h	30;"	d
MAWK_OBJ	msdos/vs2008.mak	/^MAWK_OBJ = $(OBJ1) $(OBJ2) $(OBJ3)$/;"	m
MAWK_OBJ	vs6.mak	/^MAWK_OBJ = $(OBJ1) $(OBJ2) $(OBJ3)$/;"	m
MAWK_OPCODES	code.h	/^} MAWK_OPCODES;$/;"	t	typeref:enum:__anon24
MAWK_REPL_H	regexp.h	25;"	d
MAWK_TYPES_H	types.h	20;"	d
MAX_AVE_LIST_LENGTH	array.c	49;"	d	file:
MAX_BUFFS	sizes.h	77;"	d
MAX_COMPILE_ERRORS	sizes.h	83;"	d
MAX_MATCHES	regexp_system.c	360;"	d	file:
MAX_SPLIT	re_cmpl.c	164;"	d	file:
MAX__INT	msdos/vs2008.h	24;"	d
MAX__INT	sizes.h	26;"	d
MAX__LONG	msdos/vs2008.h	25;"	d
MAX__LONG	sizes.h	27;"	d
MAX__UINT	sizes.h	28;"	d
MAX__ULONG	msdos/vs2008.h	26;"	d
MC	jmp.c	/^} MC;$/;"	t	typeref:struct:mc	file:
MEMORY_FAILURE	rexp.h	103;"	d
MINUS	parse.c	156;"	d	file:
MINUS	parse.h	33;"	d
MOD	parse.c	159;"	d	file:
MOD	parse.h	36;"	d
MOD_ASG	parse.c	139;"	d	file:
MOD_ASG	parse.h	16;"	d
MORE_CH	regexp_system.c	34;"	d	file:
MORE_DIGITS	regexp_system.c	46;"	d	file:
MUL	parse.c	157;"	d	file:
MUL	parse.h	34;"	d
MUL_ASG	parse.c	137;"	d	file:
MUL_ASG	parse.h	14;"	d
MX	bi_funct.c	732;"	d	file:
MX	bi_funct.c	854;"	d	file:
M_1J	rexp.h	43;"	d
M_2JA	rexp.h	44;"	d
M_2JB	rexp.h	45;"	d
M_2JC	rexp.h	47;"	d
M_ACCEPT	rexp.h	48;"	d
M_ANY	rexp.h	39;"	d
M_CLASS	rexp.h	38;"	d
M_END	rexp.h	41;"	d
M_SAVE_POS	rexp.h	46;"	d
M_START	rexp.h	40;"	d
M_STR	rexp.h	37;"	d
M_U	rexp.h	42;"	d
Malloc	zmalloc.c	72;"	d	file:
Malloc	zmalloc.c	75;"	d	file:
Max_Int	sizes.h	35;"	d
Max_Int	sizes.h	39;"	d
Max_UInt	sizes.h	46;"	d
Max_UInt	sizes.h	50;"	d
NEQ	parse.c	148;"	d	file:
NEQ	parse.h	25;"	d
NEXT	parse.c	195;"	d	file:
NEXT	parse.h	72;"	d
NEXTFILE	parse.c	196;"	d	file:
NEXTFILE	parse.h	73;"	d
NEXT_CH	regexp_system.c	35;"	d	file:
NF	field.h	58;"	d
NF	field.h	74;"	d
NF_PUSHI	code.h	/^    ,NF_PUSHI$/;"	e	enum:__anon24
NF_field	field.h	67;"	d
NL	parse.c	126;"	d	file:
NL	parse.h	3;"	d
NOINIT_AND_DOUBLE	types.h	49;"	d
NOINIT_AND_MBSTRN	types.h	55;"	d
NOINIT_AND_STRING	types.h	50;"	d
NOINIT_AND_STRNUM	types.h	51;"	d
NOT	parse.c	160;"	d	file:
NOT	parse.h	37;"	d
NOT_AN_IVALUE	array.c	45;"	d	file:
NOT_HEX	rexp0.c	753;"	d	file:
NOT_STARTED	rexp0.c	76;"	d	file:
NO_CREATE	array.h	42;"	d
NO_SCOPE	jmp.c	191;"	d	file:
NR	bi_vars.h	40;"	d
NR_flag	scan.c	/^int NR_flag;			\/* are we tracking NR *\/$/;"	v
NSTD_H	nstd.h	44;"	d
NUM_BI_VAR	bi_vars.h	52;"	d
NUM_BI_VAR	bi_vars.h	54;"	d
NUM_CELL_TYPES	types.h	/^    ,NUM_CELL_TYPES$/;"	e	enum:__anon11
NUM_PFIELDS	field.h	47;"	d
NextUChar	scan.c	60;"	d	file:
Next_D	examples/hcal	/^function Next_D() {$/;"	f
Next_M	examples/hcal	/^function Next_M() {$/;"	f
Next_Y	examples/hcal	/^function Next_Y() {$/;"	f
OBJ1	msdos/vs2008.mak	/^OBJ1 =	parse.obj array.obj bi_funct.obj bi_vars.obj cast.obj code.obj \\$/;"	m
OBJ1	vs6.mak	/^OBJ1 =	parse.obj array.obj bi_funct.obj bi_vars.obj cast.obj code.obj \\$/;"	m
OBJ2	msdos/vs2008.mak	/^OBJ2 =	field.obj files.obj fin.obj hash.obj jmp.obj init.obj \\$/;"	m
OBJ2	vs6.mak	/^OBJ2 =	field.obj files.obj fin.obj hash.obj jmp.obj init.obj \\$/;"	m
OBJ3	msdos/vs2008.mak	/^OBJ3 =	memory.obj print.obj re_cmpl.obj scan.obj scancode.obj split.obj \\$/;"	m
OBJ3	vs6.mak	/^OBJ3 =	memory.obj print.obj re_cmpl.obj scan.obj scancode.obj split.obj \\$/;"	m
OFMT	field.h	62;"	d
OFMT	field.h	78;"	d
OFMT_field	field.h	71;"	d
OFS	bi_vars.h	44;"	d
OL_GL	code.h	/^    ,OL_GL$/;"	e	enum:__anon24
OL_GL_NR	code.h	/^    ,OL_GL_NR$/;"	e	enum:__anon24
OP_NAME	da.c	/^} OP_NAME;$/;"	t	typeref:struct:__anon2	file:
OR	parse.c	143;"	d	file:
OR	parse.h	20;"	d
ORS	bi_vars.h	45;"	d
OVFLFIX	matherr.c	256;"	d	file:
OVFLOW	matherr.c	253;"	d	file:
PAGESZ	code.h	24;"	d
PAT1	execute.c	1190;"	d	file:
PAT2	execute.c	1187;"	d	file:
PATCH_BASE	patchlev.h	16;"	d
PATCH_LEVEL	patchlev.h	17;"	d
PATCH_STRING	patchlev.h	18;"	d
PA_block	parse.y	/^PA_block  :  block$/;"	l
PFILE	init.h	/^} PFILE;$/;"	t	typeref:struct:pfile
PF_C	print.c	/^    PF_C = 0,			\/* %c *\/$/;"	e	enum:__anon7	file:
PF_CP	types.h	/^typedef CELL *(*PF_CP) (CELL *);$/;"	t
PF_D	print.c	/^    PF_D,			\/* int conversion *\/$/;"	e	enum:__anon7	file:
PF_F	print.c	/^    PF_F,			\/* float conversion *\/$/;"	e	enum:__anon7	file:
PF_S	print.c	/^    PF_S,			\/* %s *\/$/;"	e	enum:__anon7	file:
PF_U	print.c	/^    PF_U,			\/* unsigned conversion *\/$/;"	e	enum:__anon7	file:
PF_enum	print.c	/^} PF_enum;$/;"	t	typeref:enum:__anon7	file:
PF_last	print.c	/^    PF_last$/;"	e	enum:__anon7	file:
PIPE	parse.c	163;"	d	file:
PIPE	parse.h	40;"	d
PIPE_IN	files.h	25;"	d
PIPE_OUT	files.h	26;"	d
PLUS	parse.c	155;"	d	file:
PLUS	parse.h	32;"	d
POOLSZ	zmalloc.c	47;"	d	file:
POP_AL	code.h	/^    ,POP_AL$/;"	e	enum:__anon24
POW	parse.c	164;"	d	file:
POW	parse.h	41;"	d
POW_ASG	parse.c	140;"	d	file:
POW_ASG	parse.h	17;"	d
PRINT	parse.c	178;"	d	file:
PRINT	parse.h	55;"	d
PRINTER	print.c	/^typedef int (*PRINTER) (PTR, const char *,...);$/;"	t	file:
PRINTF	parse.c	179;"	d	file:
PRINTF	parse.h	56;"	d
PROG	test/mawktest.bat	/^	set PROG=..\\mawk$/;"	v
PTR	nstd.h	/^typedef void *PTR;$/;"	t
PTR_DATA	zmalloc.c	/^} PTR_DATA;$/;"	t	typeref:struct:__anon19	file:
PUTS_C_ARGS	print.c	622;"	d	file:
PUTS_S_ARGS	print.c	623;"	d	file:
P_WAIT	msdos/dosexec.c	55;"	d	file:
Prev_D	examples/hcal	/^function Prev_D() {$/;"	f
Prev_M	examples/hcal	/^function Prev_M() {$/;"	f
Prev_Y	examples/hcal	/^function Prev_Y() {$/;"	f
Print_Summary	msdos/examples/winexe.awk	/^function Print_Summary () {$/;"	f
Q	bi_funct.c	734;"	d	file:
Q	bi_funct.c	855;"	d	file:
QMARK	parse.c	141;"	d	file:
QMARK	parse.h	18;"	d
R	bi_funct.c	735;"	d	file:
R	bi_funct.c	856;"	d	file:
RBOX	parse.c	131;"	d	file:
RBOX	parse.h	8;"	d
RBRACE	parse.c	129;"	d	file:
RBRACE	parse.h	6;"	d
RE	parse.c	172;"	d	file:
RE	parse.h	49;"	d
REPL_H	repl.h	27;"	d
REPL_NODE	re_cmpl.c	/^} REPL_NODE;$/;"	t	typeref:struct:repl_node	file:
REPL_compile	re_cmpl.c	/^REPL_compile(STRING * sval)$/;"	f	file:
RETURN	parse.c	197;"	d	file:
RETURN	parse.h	74;"	d
REXP_H	rexp.h	19;"	d
RE_01	rexp1.c	/^RE_01(MACHINE * mp)$/;"	f
RE_CASE	regexp.c	17;"	d	file:
RE_DATA	repl.h	/^} RE_DATA;$/;"	t	typeref:struct:re_data
RE_FILL	regexp.c	16;"	d	file:
RE_NODE	re_cmpl.c	/^} RE_NODE;$/;"	t	typeref:struct:re_node	file:
RE_TURN	rexp3.c	36;"	d	file:
RE_any	rexp1.c	/^RE_any(void)$/;"	f
RE_as_arg	parse.c	/^RE_as_arg(void)$/;"	f	file:
RE_cat	rexp1.c	/^RE_cat(MACHINE * mp, MACHINE * np)$/;"	f
RE_class	rexp1.c	/^RE_class(BV * bvp)$/;"	f
RE_close	rexp1.c	/^RE_close(MACHINE * mp)$/;"	f
RE_end	rexp1.c	/^RE_end(void)$/;"	f
RE_error_trap	rexp.c	/^RE_error_trap(int x)$/;"	f
RE_free	rexp.h	32;"	d
RE_free	rexp1.c	/^RE_free(PTR p)$/;"	f
RE_lex	rexp0.c	/^RE_lex(MACHINE * mp)$/;"	f
RE_lex_init	rexp0.c	/^RE_lex_init(char *re, size_t len)$/;"	f
RE_malloc	rexp1.c	/^RE_malloc(size_t sz)$/;"	f
RE_new_pos_stack	rexp2.c	/^RE_new_pos_stack(void)$/;"	f
RE_new_run_stack	rexp2.c	/^RE_new_run_stack(void)$/;"	f
RE_or	rexp1.c	/^RE_or(MACHINE * mp, MACHINE * np)$/;"	f
RE_panic	rexp.c	/^RE_panic(const char *s)$/;"	f
RE_pos_pop	rexp.h	/^RE_pos_pop(RT_POS_ENTRY ** head, const RT_STATE * current)$/;"	f
RE_pos_push	rexp.h	/^RE_pos_push(RT_POS_ENTRY * head, const RT_STATE * owner, const char *s)$/;"	f
RE_pos_stack_base	rexp2.c	/^RT_POS_ENTRY *RE_pos_stack_base;$/;"	v
RE_pos_stack_empty	rexp2.c	/^RT_POS_ENTRY *RE_pos_stack_empty;$/;"	v
RE_pos_stack_init	rexp2.c	/^RE_pos_stack_init(void)$/;"	f
RE_pos_stack_limit	rexp2.c	/^RT_POS_ENTRY *RE_pos_stack_limit;$/;"	v
RE_poscl	rexp1.c	/^RE_poscl(MACHINE * mp)$/;"	f
RE_realloc	rexp1.c	/^RE_realloc(PTR p, size_t sz)$/;"	f
RE_run_stack_base	rexp2.c	/^RT_STATE *RE_run_stack_base;$/;"	v
RE_run_stack_empty	rexp2.c	/^RT_STATE *RE_run_stack_empty;$/;"	v
RE_run_stack_init	rexp2.c	/^RE_run_stack_init(void)$/;"	f
RE_run_stack_limit	rexp2.c	/^RT_STATE *RE_run_stack_limit;$/;"	v
RE_start	rexp1.c	/^RE_start(void)$/;"	f
RE_str	rexp1.c	/^RE_str(char *str, size_t len)$/;"	f
RE_u	rexp1.c	/^RE_u(void)$/;"	f
REcompile	regexp_system.c	/^REcompile(char *regexp, size_t len)$/;"	f
REcompile	rexp.c	/^REcompile(char *re, size_t len)$/;"	f
REdestroy	regexp_system.c	/^REdestroy(PTR ptr)$/;"	f
REdestroy	rexp.c	/^REdestroy(PTR ptr)$/;"	f
REerrlist	rexp.c	/^const char *const REerrlist[] =$/;"	v
REerrno	rexp.c	/^int REerrno;$/;"	v
REerror	regexp_system.c	/^REerror(void)$/;"	f
REerror	rexp.c	/^REerror(void)$/;"	f
REmatch	regexp_system.c	/^REmatch(char *str, size_t str_len GCC_UNUSED, PTR q, size_t *lenp, int no_bol)$/;"	f
REmatch	rexp3.c	/^REmatch(char *str,		\/* string to test *\/$/;"	f
REmprint	regexp_system.c	/^REmprint(void *m, FILE *f)$/;"	f
REmprint	rexpdb.c	/^REmprint(PTR m, FILE *f)$/;"	f
REs_type	rexpdb.c	/^REs_type(PTR p)$/;"	f
REtest	regexp_system.c	/^REtest(char *str, size_t str_len GCC_UNUSED, PTR q)$/;"	f
REtest	rexp2.c	/^REtest(char *str,		\/* string to test *\/$/;"	f
RLENGTH	bi_vars.h	46;"	d
RPAREN	parse.c	169;"	d	file:
RPAREN	parse.h	46;"	d
RS	field.h	59;"	d
RS	field.h	75;"	d
RSTART	bi_vars.h	47;"	d
RS_field	field.h	68;"	d
RT_POS_ENTRY	rexp.h	/^} RT_POS_ENTRY;$/;"	t	typeref:struct:__anon18
RT_STATE	rexp.h	/^} RT_STATE;			\/* run time state *\/$/;"	t	typeref:struct:__anon17
RecordPtr	zmalloc.c	186;"	d	file:
RecordPtr	zmalloc.c	189;"	d	file:
SAFETY	execute.c	42;"	d	file:
SCANCODE_H_INCLUDED	scancode.h	21;"	d
SCAN_H	split.h	20;"	d
SCAN_H_INCLUDED	scan.h	34;"	d
SCOPE_BEGIN	code.h	30;"	d
SCOPE_END	code.h	31;"	d
SCOPE_FUNCT	code.h	32;"	d
SCOPE_MAIN	code.h	29;"	d
SC_AND	scancode.h	36;"	d
SC_COLON	scancode.h	34;"	d
SC_COMMA	scancode.h	56;"	d
SC_COMMENT	scancode.h	51;"	d
SC_DIGIT	scancode.h	48;"	d
SC_DIV	scancode.h	40;"	d
SC_DOLLAR	scancode.h	59;"	d
SC_DOT	scancode.h	57;"	d
SC_DQUOTE	scancode.h	49;"	d
SC_EQUAL	scancode.h	52;"	d
SC_ESCAPE	scancode.h	50;"	d
SC_FAKE_SEMI_COLON	scancode.h	30;"	d
SC_GT	scancode.h	55;"	d
SC_IDCHAR	scancode.h	47;"	d
SC_LBOX	scancode.h	45;"	d
SC_LBRACE	scancode.h	31;"	d
SC_LPAREN	scancode.h	43;"	d
SC_LT	scancode.h	54;"	d
SC_MATCH	scancode.h	58;"	d
SC_MINUS	scancode.h	38;"	d
SC_MOD	scancode.h	41;"	d
SC_MUL	scancode.h	39;"	d
SC_NL	scancode.h	28;"	d
SC_NOT	scancode.h	53;"	d
SC_OR	scancode.h	35;"	d
SC_PLUS	scancode.h	37;"	d
SC_POW	scancode.h	42;"	d
SC_QMARK	scancode.h	33;"	d
SC_RBOX	scancode.h	46;"	d
SC_RBRACE	scancode.h	32;"	d
SC_RPAREN	scancode.h	44;"	d
SC_SEMI_COLON	scancode.h	29;"	d
SC_SPACE	scancode.h	27;"	d
SC_UNEXPECTED	scancode.h	60;"	d
SEMI_COLON	parse.c	127;"	d	file:
SEMI_COLON	parse.h	4;"	d
SEPARATOR	field.h	/^} SEPARATOR;$/;"	t	typeref:struct:__anon4
SEP_CHAR	field.h	86;"	d
SEP_MLR	field.h	89;"	d
SEP_RE	field.h	88;"	d
SEP_SPACE	field.h	85;"	d
SEP_STR	field.h	87;"	d
SET_ALOOP	code.h	/^    ,SET_ALOOP$/;"	e	enum:__anon24
SET_PROGNAME	init.c	61;"	d	file:
SET_PROGNAME	msdos/vs2008.h	30;"	d
SET_PROGNAME	msdos/vs2008.h	32;"	d
SHORT_INTS	sizes.h	32;"	d
SHORT_UINTS	sizes.h	43;"	d
SHOW_RANDOM	version.c	36;"	d	file:
SHOW_REGEXP	version.c	43;"	d	file:
SIZES_H	sizes.h	20;"	d
SIZE_T_STDDEF_H	msdos/vs2008.h	23;"	d
SLen	types.h	/^typedef size_t SLen;$/;"	t
SPLIT	parse.c	180;"	d	file:
SPLIT	parse.h	57;"	d
SPLIT_OV	field.h	/^} SPLIT_OV;$/;"	t	typeref:struct:spov
SPRINTF_LIMIT	sizes.h	66;"	d
SP_SIZE	split.c	34;"	d	file:
SP_SIZE	split.c	36;"	d	file:
STACKGROWTH	rexp2.c	22;"	d	file:
STACKSZ	rexp.c	49;"	d	file:
STARTING_HMASK	array.c	48;"	d	file:
START_FLAG	fin.h	48;"	d
STATE	rexp.h	/^} STATE;$/;"	t	typeref:struct:__anon14
STATESZ	rexp.h	67;"	d
STDC_MATHERR	nstd.h	70;"	d
STDC_MATHERR	nstd.h	72;"	d
STDOUT	test/mawktest.bat	/^	set STDOUT=temp$\$$/;"	v
STRING	types.h	/^} STRING;$/;"	t	typeref:struct:__anon12
STRING_	parse.c	171;"	d	file:
STRING_	parse.h	48;"	d
STRING_AND_MBSTRN	types.h	57;"	d
STRING_AND_STRNUM	types.h	54;"	d
STRING_OH	types.h	70;"	d
STRNUM_AND_MBSTRN	types.h	58;"	d
ST_ARRAY	symtype.h	/^    ,ST_ARRAY			\/* a void * ptr to a hash table *\/$/;"	e	enum:__anon28
ST_BUILTIN	symtype.h	/^    ,ST_BUILTIN			\/* a pointer to a builtin record *\/$/;"	e	enum:__anon28
ST_ENV	symtype.h	/^    ,ST_ENV			\/* and so is ENVIRON *\/$/;"	e	enum:__anon28
ST_FIELD	symtype.h	/^    ,ST_FIELD			\/* a cell ptr to a field *\/$/;"	e	enum:__anon28
ST_FUNCT	symtype.h	/^    ,ST_FUNCT$/;"	e	enum:__anon28
ST_KEYWORD	symtype.h	/^    ,ST_KEYWORD$/;"	e	enum:__anon28
ST_LENGTH	symtype.h	/^    ,ST_LENGTH			\/* ditto and bozo *\/$/;"	e	enum:__anon28
ST_LOCAL_ARRAY	symtype.h	/^    ,ST_LOCAL_ARRAY$/;"	e	enum:__anon28
ST_LOCAL_NONE	symtype.h	/^    ,ST_LOCAL_NONE$/;"	e	enum:__anon28
ST_LOCAL_VAR	symtype.h	/^    ,ST_LOCAL_VAR$/;"	e	enum:__anon28
ST_NONE	symtype.h	/^    ST_NONE$/;"	e	enum:__anon28
ST_NR	symtype.h	/^    ,ST_NR			\/*  NR is special *\/$/;"	e	enum:__anon28
ST_VAR	symtype.h	/^    ,ST_VAR$/;"	e	enum:__anon28
SType	types.h	/^typedef int SType;$/;"	t
SUB	parse.c	182;"	d	file:
SUB	parse.h	59;"	d
SUBSEP	bi_vars.h	48;"	d
SUB_ASG	parse.c	136;"	d	file:
SUB_ASG	parse.h	13;"	d
SYMTAB	symtype.h	/^} SYMTAB;$/;"	t	typeref:struct:__anon29
SYMTAB_TYPES	symtype.h	/^} SYMTAB_TYPES;$/;"	t	typeref:enum:__anon28
SYMTYPE_H	symtype.h	20;"	d
ShowPtrData	zmalloc.c	105;"	d	file:
Split_Block_Node	split.c	/^} Split_Block_Node;$/;"	t	typeref:struct:split_block	file:
SprintfBlock	print.c	/^SprintfBlock(char *buffer, char *source, int length)$/;"	f	file:
SprintfChar	print.c	/^SprintfChar(char *buffer, int ch)$/;"	f	file:
SprintfFill	print.c	/^SprintfFill(char *buffer, int ch, int fill)$/;"	f	file:
SprintfOverflow	print.c	277;"	d	file:
Summary	test/mawktest	/^Summary() {$/;"	f
TEST2	mawk.h	103;"	d
TESTNAME	test/mawktest.bat	/^	set TESTNAME=%1$/;"	v
TRACE	mawk.h	178;"	d
TRACE	mawk.h	185;"	d
TRACE2	mawk.h	180;"	d
TRACE2	mawk.h	189;"	d
TRACE_CELL	mawk.h	196;"	d
TRACE_CELL	mawk.h	200;"	d
TRACE_FUNC	mawk.h	207;"	d
TRACE_FUNC	mawk.h	209;"	d
TRACE_INST	mawk.h	214;"	d
TRACE_INST	mawk.h	216;"	d
TRACE_STRING	mawk.h	197;"	d
TRACE_STRING	mawk.h	201;"	d
TRACE_STRING2	mawk.h	198;"	d
TRACE_STRING2	mawk.h	202;"	d
TR_STR	rexp3.c	35;"	d	file:
TURN_OFF_FPE_TRAPS	matherr.c	68;"	d	file:
TURN_ON_FPE_TRAPS	matherr.c	72;"	d	file:
TWO_DOUBLES	types.h	45;"	d
TWO_MBSTRNS	types.h	48;"	d
TWO_NOINITS	types.h	44;"	d
TWO_STRINGS	types.h	46;"	d
TWO_STRNUMS	types.h	47;"	d
T_ANY	rexp.h	84;"	d
T_CAT	rexp.h	76;"	d
T_CHAR	rexp.h	87;"	d
T_CLASS	rexp.h	85;"	d
T_END	rexp.h	83;"	d
T_LP	rexp.h	80;"	d
T_NONE	rexp.h	74;"	d
T_OR	rexp.h	75;"	d
T_PLUS	rexp.h	78;"	d
T_Q	rexp.h	79;"	d
T_RP	rexp.h	81;"	d
T_SLASH	rexp.h	86;"	d
T_STAR	rexp.h	77;"	d
T_START	rexp.h	82;"	d
T_STR	rexp.h	88;"	d
T_U	rexp.h	89;"	d
Trace	trace.c	/^Trace(const char *format, ...)$/;"	f
TraceCell	trace.c	/^TraceCell(CELL *cp)$/;"	f
TraceFunc	trace.c	/^TraceFunc(const char *name, CELL *sp)$/;"	f
TraceInst	trace.c	/^TraceInst(INST * p, INST * base)$/;"	f
TraceString	trace.c	/^TraceString(STRING * sp)$/;"	f
TraceString2	trace.c	/^TraceString2(const char *str, size_t len)$/;"	f
TraceVA	trace.c	/^TraceVA(const char *format, va_list args)$/;"	f
UChar	types.h	/^typedef unsigned char UChar;$/;"	t
UFLOW	matherr.c	254;"	d	file:
UINT_FMT	sizes.h	44;"	d
UINT_FMT	sizes.h	48;"	d
UInt	sizes.h	/^typedef unsigned UInt;$/;"	t
UInt	sizes.h	/^typedef unsigned long UInt;$/;"	t
UMINUS	parse.c	161;"	d	file:
UMINUS	parse.h	38;"	d
UNEXPECTED	parse.c	124;"	d	file:
UNEXPECTED	parse.h	1;"	d
USED_SPLIT_BUFF	mawk.h	260;"	d
USED_SPLIT_BUFF	mawk.h	262;"	d
USE_BINMODE	mawk.h	61;"	d
USE_BINMODE	mawk.h	63;"	d
USE_SYSTEM_SRAND	bi_funct.c	33;"	d	file:
USE_TSEARCH	zmalloc.c	22;"	d	file:
U_OFF	rexp.h	51;"	d
U_ON	rexp.h	49;"	d
VCount	types.h	/^typedef unsigned short VCount;$/;"	t
VERSION_STRING	version.c	21;"	d	file:
WHILE	parse.c	185;"	d	file:
WHILE	parse.h	62;"	d
W_BINMODE	init.c	/^    W_BINMODE,$/;"	e	enum:__anon1	file:
W_DUMP	init.c	/^    W_DUMP,$/;"	e	enum:__anon1	file:
W_EXEC	init.c	/^    W_EXEC,$/;"	e	enum:__anon1	file:
W_HELP	init.c	/^    W_HELP,$/;"	e	enum:__anon1	file:
W_INTERACTIVE	init.c	/^    W_INTERACTIVE,$/;"	e	enum:__anon1	file:
W_OPTIONS	init.c	/^} W_OPTIONS;$/;"	t	typeref:enum:__anon1	file:
W_POSIX_SPACE	init.c	/^    W_POSIX_SPACE,$/;"	e	enum:__anon1	file:
W_RANDOM	init.c	/^    W_RANDOM,$/;"	e	enum:__anon1	file:
W_SPRINTF	init.c	/^    W_SPRINTF,$/;"	e	enum:__anon1	file:
W_UNKNOWN	init.c	/^    W_UNKNOWN = 0,$/;"	e	enum:__anon1	file:
W_USAGE	init.c	/^    W_USAGE$/;"	e	enum:__anon1	file:
W_VERSION	init.c	/^    W_VERSION,$/;"	e	enum:__anon1	file:
YYABORT	parse.c	1584;"	d	file:
YYACCEPT	parse.c	1586;"	d	file:
YYBYACC	parse.c	5;"	d	file:
YYDEBUG	mawk.h	55;"	d
YYDEBUG	parse.c	970;"	d	file:
YYEMPTY	parse.c	10;"	d	file:
YYENOMEM	parse.c	14;"	d	file:
YYEOF	parse.c	15;"	d	file:
YYERRCODE	parse.c	199;"	d	file:
YYERROR	parse.c	1587;"	d	file:
YYERROR_CALL	parse.c	119;"	d	file:
YYERROR_DECL	parse.c	116;"	d	file:
YYFINAL	parse.c	968;"	d	file:
YYINITSTACKSIZE	parse.c	1198;"	d	file:
YYINT	parse.c	/^typedef short YYINT;$/;"	t	file:
YYLEX	parse.c	104;"	d	file:
YYLEX	parse.c	107;"	d	file:
YYLEX_DECL	parse.c	103;"	d	file:
YYLEX_DECL	parse.c	106;"	d	file:
YYMAJOR	parse.c	6;"	d	file:
YYMAXDEPTH	parse.c	1187;"	d	file:
YYMAXDEPTH	parse.c	1188;"	d	file:
YYMAXDEPTH	parse.c	1194;"	d	file:
YYMAXDEPTH	parse.c	33;"	d	file:
YYMAXTOKEN	parse.c	972;"	d	file:
YYMINOR	parse.c	7;"	d	file:
YYPARSE_DECL	parse.c	/^YYPARSE_DECL()$/;"	f
YYPARSE_DECL	parse.c	93;"	d	file:
YYPARSE_DECL	parse.c	95;"	d	file:
YYPARSE_DECL	parse.c	98;"	d	file:
YYPATCH	parse.c	8;"	d	file:
YYPREFIX	parse.c	16;"	d	file:
YYPURE	parse.c	18;"	d	file:
YYRECOVERING	parse.c	13;"	d	file:
YYREJECT	parse.c	1585;"	d	file:
YYSTACKDATA	parse.c	/^} YYSTACKDATA;$/;"	t	typeref:struct:__anon10	file:
YYSTACKSIZE	parse.c	1191;"	d	file:
YYSTACKSIZE	parse.c	1193;"	d	file:
YYSTYPE	parse.c	/^} YYSTYPE;$/;"	t	typeref:union:__anon9	file:
YYSTYPE	parse.h	/^} YYSTYPE;$/;"	t	typeref:union:__anon6
YYSTYPE_IS_DECLARED	parse.c	68;"	d	file:
YYSTYPE_IS_DECLARED	parse.c	69;"	d	file:
YYSTYPE_IS_DECLARED	parse.c	72;"	d	file:
YYSTYPE_IS_DECLARED	parse.h	77;"	d
YYSTYPE_IS_DECLARED	parse.h	78;"	d
YYSTYPE_IS_DECLARED	parse.h	81;"	d
YYTABLESIZE	parse.c	365;"	d	file:
YYTRANSLATE	parse.c	974;"	d	file:
YYUNDFTOKEN	parse.c	973;"	d	file:
ZBLOCK	zmalloc.c	/^} ZBLOCK;$/;"	t	typeref:union:zblock	file:
ZBLOCKSZ	zmalloc.c	30;"	d	file:
ZERODIV	matherr.c	255;"	d	file:
ZFREE	zmalloc.h	39;"	d
ZMALLOC	zmalloc.h	38;"	d
ZMALLOC_H	zmalloc.h	30;"	d
ZSHIFT	zmalloc.c	29;"	d	file:
_ADD	code.h	/^    ,_ADD$/;"	e	enum:__anon24
_ADD_ASG	code.h	/^    ,_ADD_ASG$/;"	e	enum:__anon24
_ASSIGN	code.h	/^    ,_ASSIGN$/;"	e	enum:__anon24
_BUILTIN	code.h	/^    ,_BUILTIN$/;"	e	enum:__anon24
_CALL	code.h	/^    ,_CALL$/;"	e	enum:__anon24
_CAT	code.h	/^    ,_CAT$/;"	e	enum:__anon24
_DIV	code.h	/^    ,_DIV$/;"	e	enum:__anon24
_DIV_ASG	code.h	/^    ,_DIV_ASG$/;"	e	enum:__anon24
_EQ	code.h	/^    ,_EQ$/;"	e	enum:__anon24
_EXIT	code.h	/^    ,_EXIT$/;"	e	enum:__anon24
_EXIT0	code.h	/^    ,_EXIT0$/;"	e	enum:__anon24
_GT	code.h	/^    ,_GT$/;"	e	enum:__anon24
_GTE	code.h	/^    ,_GTE$/;"	e	enum:__anon24
_HALT	code.h	/^    ,_HALT$/;"	e	enum:__anon24
_JMAIN	code.h	/^    ,_JMAIN$/;"	e	enum:__anon24
_JMP	code.h	/^    ,_JMP$/;"	e	enum:__anon24
_JNZ	code.h	/^    ,_JNZ$/;"	e	enum:__anon24
_JZ	code.h	/^    ,_JZ$/;"	e	enum:__anon24
_LJNZ	code.h	/^    ,_LJNZ$/;"	e	enum:__anon24
_LJZ	code.h	/^    ,_LJZ$/;"	e	enum:__anon24
_LT	code.h	/^    ,_LT$/;"	e	enum:__anon24
_LTE	code.h	/^    ,_LTE$/;"	e	enum:__anon24
_MATCH0	code.h	/^    ,_MATCH0$/;"	e	enum:__anon24
_MATCH1	code.h	/^    ,_MATCH1$/;"	e	enum:__anon24
_MATCH2	code.h	/^    ,_MATCH2$/;"	e	enum:__anon24
_MOD	code.h	/^    ,_MOD$/;"	e	enum:__anon24
_MOD_ASG	code.h	/^    ,_MOD_ASG$/;"	e	enum:__anon24
_MUL	code.h	/^    ,_MUL$/;"	e	enum:__anon24
_MUL_ASG	code.h	/^    ,_MUL_ASG$/;"	e	enum:__anon24
_NEQ	code.h	/^    ,_NEQ$/;"	e	enum:__anon24
_NEXT	code.h	/^    ,_NEXT$/;"	e	enum:__anon24
_NEXTFILE	code.h	/^    ,_NEXTFILE$/;"	e	enum:__anon24
_NOT	code.h	/^    ,_NOT$/;"	e	enum:__anon24
_OMAIN	code.h	/^    ,_OMAIN$/;"	e	enum:__anon24
_POP	code.h	/^    ,_POP$/;"	e	enum:__anon24
_POSIX_	msdos/dosexec.c	50;"	d	file:
_POST_DEC	code.h	/^    ,_POST_DEC$/;"	e	enum:__anon24
_POST_INC	code.h	/^    ,_POST_INC$/;"	e	enum:__anon24
_POW	code.h	/^    ,_POW$/;"	e	enum:__anon24
_POW_ASG	code.h	/^    ,_POW_ASG$/;"	e	enum:__anon24
_PRE_DEC	code.h	/^    ,_PRE_DEC$/;"	e	enum:__anon24
_PRE_INC	code.h	/^    ,_PRE_INC$/;"	e	enum:__anon24
_PRINT	code.h	/^    ,_PRINT$/;"	e	enum:__anon24
_PUSHA	code.h	/^    ,_PUSHA$/;"	e	enum:__anon24
_PUSHC	code.h	/^    ,_PUSHC$/;"	e	enum:__anon24
_PUSHD	code.h	/^    ,_PUSHD$/;"	e	enum:__anon24
_PUSHI	code.h	/^    ,_PUSHI$/;"	e	enum:__anon24
_PUSHINT	code.h	/^    ,_PUSHINT$/;"	e	enum:__anon24
_PUSHS	code.h	/^    ,_PUSHS$/;"	e	enum:__anon24
_RANGE	code.h	/^    ,_RANGE$/;"	e	enum:__anon24
_RET	code.h	/^    ,_RET$/;"	e	enum:__anon24
_RET0	code.h	/^    ,_RET0$/;"	e	enum:__anon24
_STOP	code.h	/^    ,_STOP$/;"	e	enum:__anon24
_SUB	code.h	/^    ,_SUB$/;"	e	enum:__anon24
_SUB_ASG	code.h	/^    ,_SUB_ASG$/;"	e	enum:__anon24
_TEST	code.h	/^    ,_TEST$/;"	e	enum:__anon24
_UMINUS	code.h	/^    ,_UMINUS$/;"	e	enum:__anon24
_UPLUS	code.h	/^    ,_UPLUS$/;"	e	enum:__anon24
_all_arrays	init.c	/^typedef struct _all_arrays {$/;"	s	file:
_all_cells	cast.c	/^typedef struct _all_cells {$/;"	s	file:
_all_ptrs	re_cmpl.c	/^typedef struct _all_ptrs {$/;"	s	file:
a	init.c	/^    ARRAY a;$/;"	m	struct:_all_arrays	file:
action	da.c	/^   PF_CP action ;$/;"	m	struct:__anon3	file:
active_arglist	parse.c	/^static CA_REC *active_arglist;$/;"	v	file:
active_code	code.c	/^CODEBLOCK active_code;$/;"	v
active_funct	parse.c	/^static FBLOCK *active_funct;$/;"	v	file:
add_string_associations	array.c	/^static void add_string_associations(ARRAY A)$/;"	f	file:
add_to_child_list	files.c	/^add_to_child_list(int pid, int exit_status)$/;"	f	file:
add_to_fdump_list	da.c	/^add_to_fdump_list(FBLOCK * fbp)$/;"	f
add_to_regex_list	da.c	/^add_to_regex_list(PTR re)$/;"	f	file:
add_to_regex_list	da.c	46;"	d	file:
ahash	array.c	51;"	d	file:
all_arrays	init.c	/^static ALL_ARRAYS *all_arrays;$/;"	v	file:
all_cells	cast.c	/^static ALL_CELLS *all_cells;$/;"	v	file:
all_ptrs	re_cmpl.c	/^static ALL_PTRS *all_ptrs;$/;"	v	file:
alloc_filenode	files.c	/^alloc_filenode(void)$/;"	f	file:
allocate_fbankv	field.c	/^allocate_fbankv(int i)$/;"	f	file:
allow_long_options	init.c	/^allow_long_options(char *arg)$/;"	f	file:
allzero	test/fpe_test.bat	/^:allzero$/;"	l
aloop_state	execute.c	/^typedef struct aloop_state {$/;"	s	file:
anchored	repl.h	/^    int anchored;		\/* use to limit recursion in gsub *\/$/;"	m	struct:re_data
anode	array.c	/^typedef struct anode {$/;"	s	file:
arg2	parse.y	/^arg2   :   expr  COMMA  expr$/;"	l
arg2p	parse.c	/^  ARG2_REC *arg2p ;$/;"	m	union:__anon9	file:
arg2p	parse.h	/^  ARG2_REC *arg2p ;$/;"	m	union:__anon6
arg_cnt_checked	symtype.h	/^    short arg_cnt_checked;$/;"	m	struct:fcall
arg_cnt_ok	fcall.c	/^arg_cnt_ok(FBLOCK * fbp,$/;"	f	file:
arg_list	symtype.h	/^    CA_REC *arg_list;$/;"	m	struct:fcall
arg_num	symtype.h	/^    short arg_num;		\/* position in callee's stack *\/$/;"	m	struct:ca_rec
argi	fin.c	/^static double argi = 1.0;	\/* index of next ARGV[argi] to try to open *\/$/;"	v	file:
arglist	parse.y	/^arglist :  \/* empty *\/$/;"	l
args	parse.y	/^args    :  expr        %prec  LPAREN$/;"	l
array	array.h	/^typedef struct array {$/;"	s
array	symtype.h	/^	ARRAY array;$/;"	m	union:__anon29::__anon30
array_cat	array.c	/^CELL *array_cat($/;"	f
array_clear	array.c	/^void array_clear(ARRAY A)$/;"	f
array_delete	array.c	/^void array_delete($/;"	f
array_find	array.c	/^CELL* array_find($/;"	f
array_leaks	init.c	/^array_leaks(void)$/;"	f
array_load	array.c	/^void array_load($/;"	f
array_loop_front	parse.y	/^array_loop_front :  FOR LPAREN ID IN ID RPAREN$/;"	l
array_loop_vector	array.c	/^STRING** array_loop_vector($/;"	f
bad_conversion	print.c	/^bad_conversion(int cnt, const char *who, const char *format)$/;"	f	file:
bad_option	init.c	/^bad_option(char *s)$/;"	f	file:
base	code.h	/^    INST *base, *limit, *warn, *ptr;$/;"	m	struct:__anon23
base	execute.c	/^    STRING **base;$/;"	m	struct:aloop_state	file:
bc	jmp.c	/^typedef struct bc {$/;"	s	file:
bc_top	jmp.c	/^static BC *bc_top;$/;"	v	file:
be_setup	code.c	/^be_setup(int scope)$/;"	f
begin	test/mawktest.bat	/^:begin$/;"	l
begin_code_p	code.c	/^CODEBLOCK *main_code_p, *begin_code_p, *end_code_p;$/;"	v
begin_size	code.c	/^size_t begin_size, main_size, end_size;$/;"	v
begin_start	code.c	/^INST *begin_start, *main_start, *end_start;$/;"	v
bi_atan2	bi_funct.c	/^bi_atan2(CELL *sp)$/;"	f
bi_close	bi_funct.c	/^bi_close(CELL *sp)$/;"	f
bi_cos	bi_funct.c	/^bi_cos(CELL *sp)$/;"	f
bi_exp	bi_funct.c	/^bi_exp(CELL *sp)$/;"	f
bi_fflush	bi_funct.c	/^bi_fflush(CELL *sp)$/;"	f
bi_funct	bi_funct.c	/^const BI_REC bi_funct[] =$/;"	v
bi_funct_init	bi_funct.c	/^bi_funct_init(void)$/;"	f
bi_getline	bi_funct.c	/^bi_getline(CELL *sp)$/;"	f
bi_gsub	bi_funct.c	/^bi_gsub(CELL *sp)$/;"	f
bi_index	bi_funct.c	/^bi_index(CELL *sp)$/;"	f
bi_int	bi_funct.c	/^bi_int(CELL *sp)$/;"	f
bi_length	bi_funct.c	/^bi_length(CELL *sp)$/;"	f
bi_log	bi_funct.c	/^bi_log(CELL *sp)$/;"	f
bi_match	bi_funct.c	/^bi_match(CELL *sp)$/;"	f
bi_mktime	bi_funct.c	/^bi_mktime(CELL *sp)$/;"	f
bi_print	print.c	/^bi_print($/;"	f
bi_printf	print.c	/^bi_printf(CELL *sp)$/;"	f
bi_rand	bi_funct.c	/^bi_rand(CELL *sp)$/;"	f
bi_sin	bi_funct.c	/^bi_sin(CELL *sp)$/;"	f
bi_split	split.c	/^bi_split(CELL *sp)$/;"	f
bi_sprintf	print.c	/^bi_sprintf(CELL *sp)$/;"	f
bi_sqrt	bi_funct.c	/^bi_sqrt(CELL *sp)$/;"	f
bi_srand	bi_funct.c	/^bi_srand(CELL *sp)$/;"	f
bi_strftime	bi_funct.c	/^bi_strftime(CELL *sp)$/;"	f
bi_sub	bi_funct.c	/^bi_sub(CELL *sp)$/;"	f
bi_substr	bi_funct.c	/^bi_substr(CELL *sp)$/;"	f
bi_system	bi_funct.c	/^bi_system(CELL *sp GCC_UNUSED)$/;"	f
bi_systime	bi_funct.c	/^bi_systime(CELL *sp)$/;"	f
bi_tolower	bi_funct.c	/^bi_tolower(CELL *sp)$/;"	f
bi_toupper	bi_funct.c	/^bi_toupper(CELL *sp)$/;"	f
bi_var_names	bi_vars.c	/^static const char *bi_var_names[NUM_BI_VAR] =$/;"	v	file:
bi_vars	bi_vars.c	/^CELL bi_vars[NUM_BI_VAR];$/;"	v
bi_vars_init	bi_vars.c	/^bi_vars_init(void)$/;"	f
bi_vars_leaks	bi_vars.c	/^bi_vars_leaks(void)$/;"	f
binmode	field.c	/^binmode(void)$/;"	f
bip	parse.c	/^  const BI_REC *bip ; \/* ptr to info about a builtin *\/$/;"	m	union:__anon9	file:
bip	parse.h	/^  const BI_REC *bip ; \/* ptr to info about a builtin *\/$/;"	m	union:__anon6
bip	symtype.h	/^	const BI_REC *bip;$/;"	m	union:__anon29::__anon30
block	parse.y	/^block   :  LBRACE   statement_list  RBRACE$/;"	l
block_on	rexp0.c	/^block_on(BV b, int x, int y)$/;"	f	file:
block_or_separator	parse.y	/^block_or_separator  :  block$/;"	l
bozo	error.c	/^bozo(const char *s)$/;"	f
brace_cnt	scan.c	/^int brace_cnt;$/;"	v
buff	fin.h	/^    char *buff;			\/* base of data read from file *\/$/;"	m	struct:__anon25
buffer	scan.c	/^static UChar *buffer;$/;"	v	file:
buffp	fin.h	/^    char *buffp;		\/* current position to read-next *\/$/;"	m	struct:__anon25
buffp	scan.c	/^static UChar *buffp;$/;"	v	file:
build_field0	field.c	/^build_field0(void)$/;"	f	file:
builtin	parse.y	/^builtin :$/;"	l
bv_base	rexp0.c	/^static BV **bv_base, **bv_limit;$/;"	v	file:
bv_limit	rexp0.c	/^static BV **bv_base, **bv_limit;$/;"	v	file:
bv_next	rexp0.c	/^static BV **bv_next;		\/* next empty slot in the array *\/$/;"	v	file:
bvp	rexp.h	/^	BV *bvp;		\/*  class  *\/$/;"	m	union:__anon14::__anon15
c	field.h	/^    char c;$/;"	m	struct:__anon4
ca_back	parse.y	/^ca_back    :  expr   RPAREN$/;"	l
ca_front	parse.y	/^ca_front   :  LPAREN$/;"	l
ca_p	parse.c	/^  CA_REC   *ca_p  ;$/;"	m	union:__anon9	file:
ca_p	parse.h	/^  CA_REC   *ca_p  ;$/;"	m	union:__anon6
ca_rec	symtype.h	/^typedef struct ca_rec {$/;"	s
call	symtype.h	/^    FBLOCK *call;		\/* only used if call_scope == SCOPE_FUNCT  *\/$/;"	m	struct:fcall
call_arg_check	fcall.c	/^call_arg_check(FBLOCK * callee,$/;"	f	file:
call_args	parse.y	/^call_args  :   LPAREN   RPAREN$/;"	l
call_lineno	symtype.h	/^    unsigned call_lineno;$/;"	m	struct:ca_rec
call_offset	symtype.h	/^    int call_offset;$/;"	m	struct:ca_rec
call_scope	symtype.h	/^    short call_scope;$/;"	m	struct:fcall
call_start	symtype.h	/^    INST *call_start;		\/* computed later as code may be moved *\/$/;"	m	struct:fcall
callee	symtype.h	/^    FBLOCK *callee;$/;"	m	struct:fcall
cast1_to_d	cast.c	/^cast1_to_d(CELL *cp)$/;"	f
cast1_to_s	cast.c	/^cast1_to_s(CELL *cp)$/;"	f
cast2_to_d	cast.c	/^cast2_to_d(CELL *cp)$/;"	f
cast2_to_s	cast.c	/^cast2_to_s(CELL *cp)$/;"	f
cast_for_split	cast.c	/^cast_for_split(CELL *cp)$/;"	f
cast_to_RE	cast.c	/^cast_to_RE(CELL *cp)$/;"	f
cast_to_REPL	cast.c	/^cast_to_REPL(CELL *cp)$/;"	f
cast_to_re	repl.h	42;"	d
cat_expr	parse.y	/^cat_expr :  p_expr             %prec CAT$/;"	l
catch_FPEs	fpe_check.c	/^catch_FPEs(void)$/;"	f	file:
cell	array.c	/^   CELL    cell ;$/;"	m	struct:anode	file:
cell	types.h	/^typedef struct cell {$/;"	s
cell_destroy	mawk.h	109;"	d
cell_destroy	mawk.h	112;"	d
cell_leaks	cast.c	/^cell_leaks(void)$/;"	f
cellcpy	execute.c	/^cellcpy(CELL *target, CELL *source)$/;"	f
char2token	rexp0.c	/^char char2token[] =$/;"	v	file:
char_on	rexp0.c	310;"	d	file:
check_array	parse.c	/^check_array(SYMTAB * p)$/;"	f	file:
check_fcall	fcall.c	/^check_fcall($/;"	f
check_fpe_traps	fpe_check.c	/^check_fpe_traps(void)$/;"	f	file:
check_progress	fcall.c	/^static int check_progress;$/;"	v	file:
check_strnum	cast.c	/^check_strnum(CELL *cp)$/;"	f
check_strtod_ovf	fpe_check.c	/^check_strtod_ovf(void)$/;"	f	file:
check_var	parse.c	/^check_var(SYMTAB * p)$/;"	f	file:
checking_for_strtod_ovf_bug	fpe_check.c	/^int checking_for_strtod_ovf_bug = 0;$/;"	v
child	files.c	/^static struct child {$/;"	s	file:
child_list	files.c	/^} *child_list;$/;"	v	typeref:struct:child	file:
chkone	test/mawktest.bat	/^:chkone$/;"	l
cleanup	test/fpe_test.bat	/^:cleanup$/;"	l
clear_aloop_stack	execute.c	/^clear_aloop_stack(ALOOP_STATE * top)$/;"	f	file:
close_error	files.c	/^close_error(FILE_NODE * p)$/;"	f	file:
close_fake_outpipe	msdos/dosexec.c	/^close_fake_outpipe(char *command,$/;"	f
close_fake_pipes	files.c	/^close_fake_pipes(void)$/;"	f
close_out_pipes	files.c	/^close_out_pipes(void)$/;"	f
cmpsp0	test/mawktest.bat	/^:cmpsp0$/;"	l
cmpsp2	test/mawktest.bat	/^:cmpsp2$/;"	l
cmpsp3	test/mawktest.bat	/^:cmpsp3$/;"	l
cnt	symtype.h	/^    int cnt;$/;"	m	struct:__anon27
code	jmp.c	/^    INST *code;			\/* the save code *\/$/;"	m	struct:mc	file:
code	symtype.h	/^    INST *code;$/;"	m	struct:fblock
code1	code.h	60;"	d
code2	code.h	62;"	d
code2op	code.c	/^code2op(int x, int y)$/;"	f
code_address	parse.c	54;"	d	file:
code_array	parse.c	/^code_array(SYMTAB * p)$/;"	f	file:
code_base	code.h	50;"	d
code_call_id	parse.c	/^code_call_id(CA_REC * p, SYMTAB * ip)$/;"	f	file:
code_grow	code.c	/^code_grow(void)$/;"	f
code_init	code.c	/^code_init(void)$/;"	f
code_jmp	jmp.c	/^code_jmp(int jtype, INST * target)$/;"	f
code_leaks	code.c	/^code_leaks(void)$/;"	f
code_limit	code.h	52;"	d
code_move_level	jmp.c	/^int code_move_level = 0;	\/* see comment in jmp.h *\/$/;"	v
code_offset	code.h	53;"	d
code_pop	jmp.c	/^code_pop(INST * target)$/;"	f
code_ptr	code.h	49;"	d
code_push	jmp.c	/^code_push(INST * code, unsigned len, int scope, FBLOCK * fbp)$/;"	f
code_shrink	code.c	/^code_shrink(CODEBLOCK * p, size_t *sizep)$/;"	f
code_warn	code.h	51;"	d
collect_RE	scan.c	/^collect_RE(void)$/;"	f	file:
collect_decimal	scan.c	/^collect_decimal(int c, int *flag)$/;"	f	file:
collect_string	scan.c	/^collect_string(void)$/;"	f	file:
command_opt	msdos/dosexec.c	/^static char *command_opt;	\/*  " \/c"  *\/$/;"	v	file:
compare	execute.c	/^compare(CELL *cp)$/;"	f	file:
compare	test/mawktest.bat	/^:compare$/;"	l
compare	test/wfrq0.awk	/^function  compare(s1, s2,	t, X)$/;"	f
compare_ptr_data	zmalloc.c	/^compare_ptr_data(const void *a, const void *b)$/;"	f	file:
compile	configure	/^compile ();$/;"	f
compile_error	error.c	/^compile_error(const char *format,...)$/;"	f
compile_error_count	scan.c	/^unsigned compile_error_count;$/;"	v
compiled	repl.h	/^    PTR compiled;$/;"	m	struct:re_data
convert_split_array_to_table	array.c	/^static void convert_split_array_to_table(ARRAY A)$/;"	f	file:
cp	cast.c	/^    CELL *cp;$/;"	m	struct:_all_cells	file:
cp	parse.c	/^  CELL     *cp ;$/;"	m	union:__anon9	file:
cp	parse.h	/^  CELL     *cp ;$/;"	m	union:__anon6
cp	re_cmpl.c	/^    CELL *cp;			\/* the output *\/$/;"	m	struct:repl_node	file:
cp	symtype.h	/^	CELL *cp;$/;"	m	union:__anon29::__anon30
crank	bi_funct.c	738;"	d	file:
crank	bi_funct.c	742;"	d	file:
crank	bi_funct.c	857;"	d	file:
cseed	bi_funct.c	/^static CELL cseed;		\/* argument of last call to srand() *\/$/;"	v	file:
ct_ret	scan.h	50;"	d
ctohex	rexp0.c	/^ctohex(int c)$/;"	f	file:
current_token	scan.c	/^int current_token = -1;$/;"	v
d_to_I	cast.c	/^d_to_I(double d)$/;"	f
d_to_U	cast.c	/^d_to_U(double d)$/;"	f
d_to_i	mawk.h	134;"	d
d_to_index	execute.c	/^d_to_index(double d)$/;"	f	file:
da	da.c	/^da(INST * p, FILE *fp)$/;"	f
da_op_name	da.c	/^da_op_name(INST * cdp)$/;"	f
da_string	da.c	/^da_string(FILE *fp, const char *str, size_t len)$/;"	f
da_this	da.c	/^da_this(INST * p, INST * start, FILE *fp)$/;"	f
da_type_name	da.c	/^da_type_name(CELL *cdp)$/;"	f
dat	test/mawktest.bat	/^	set dat=mawktest.dat$/;"	v
data	da.c	/^    FBLOCK *data;$/;"	m	struct:fdump	file:
data	da.c	/^    PTR data;$/;"	m	struct:regex	file:
dead_buff	fin.c	/^static char dead_buff = 0;$/;"	v	file:
dead_main	fin.c	/^static FIN dead_main =$/;"	v	file:
debug_malloc	configure	/^debug_malloc ();$/;"	f
dec_sp	execute.c	40;"	d	file:
decimal_dot	main.c	/^char decimal_dot;$/;"	v
decl	examples/decl.awk	/^function  decl(   x, t, ptr_part)$/;"	f
decl	examples/gdecl.awk	/^function  decl(   x, t, ptr_part)$/;"	f
delete	hash.c	/^delete(const char *s)$/;"	f	file:
div_by	fpe_check.c	/^div_by(double x, double y)$/;"	f	file:
dmalloc_debug	configure	/^dmalloc_debug ();$/;"	f
do	parse.y	/^do      :  DO$/;"	l
do_class	rexp0.c	/^do_class(char **start, MACHINE * mp)$/;"	f	file:
do_printf	print.c	/^do_printf($/;"	f	file:
do_str	rexp0.c	/^do_str($/;"	f	file:
done	test/fpe_test.bat	/^:done$/;"	l
done1	test/fpe_test.bat	/^:done1$/;"	l
dos_name	msdos/examples/doslist.awk	/^function dos_name(s,	n, front, X)$/;"	f
double_one	scan.c	/^double double_one = 1.0;$/;"	v
double_the_hash_table	array.c	/^static void double_the_hash_table(ARRAY A)$/;"	f	file:
double_zero	scan.c	/^double double_zero = 0.0;$/;"	v
down_heap	test/wfrq0.awk	/^function down_heap(i,  		k,hold) $/;"	f
dummy	zmalloc.c	/^    char dummy[ZBLOCKSZ];$/;"	m	union:zblock	file:
dump_RE	init.c	/^int dump_RE = 1;		\/* if on dump compiled REs  *\/$/;"	v
dump_code	code.c	/^dump_code(void)$/;"	f
dump_code_flag	init.c	/^int dump_code_flag;		\/* if on dump internal code *\/$/;"	v
dump_funcs	da.c	/^dump_funcs(void)$/;"	f
dump_regex	da.c	/^dump_regex(void)$/;"	f
dval	types.h	/^    double dval;$/;"	m	struct:cell
dz_msg	execute.c	/^static char dz_msg[] = "division by zero";$/;"	v	file:
eat_comment	examples/eatc.awk	/^function eat_comment(s,		t)$/;"	f
eat_comment	scan.c	/^eat_comment(void)$/;"	f	file:
eat_nl	scan.c	/^eat_nl(void)			\/* eat all space including newlines *\/$/;"	f
eat_semi_colon	scan.c	/^eat_semi_colon(void)$/;"	f	file:
efflush	files.c	/^efflush(FILE *fp)$/;"	f	file:
efmt	re_cmpl.c	/^static const char efmt[] = "regular expression compile failed (%s)\\n%s";$/;"	v	file:
else	parse.y	/^else    :  ELSE { eat_nl() ; code_jmp(_JMP, (INST*)0) ; }$/;"	l
end_code_p	code.c	/^CODEBLOCK *main_code_p, *begin_code_p, *end_code_p;$/;"	v
end_size	code.c	/^size_t begin_size, main_size, end_size;$/;"	v
end_start	code.c	/^INST *begin_start, *main_start, *end_start;$/;"	v
enlarge_fin_buffer	fin.c	/^enlarge_fin_buffer(FIN * fin)$/;"	f	file:
enlarge_output_buffer	files.c	/^enlarge_output_buffer(FILE *fp)$/;"	f
entry_mask	matherr.c	/^static fp_except entry_mask;$/;"	v	file:
enumSFMT	print.c	/^} enumSFMT;$/;"	t	typeref:enum:__anon8	file:
eof_flag	scan.c	/^static int eof_flag;$/;"	v	file:
err_buf	rexp.c	/^static jmp_buf err_buf;		\/*  used to trap on error *\/$/;"	v	file:
err_code	regexp_system.c	/^static int err_code = 0;$/;"	v	file:
errmsg	error.c	/^errmsg(int errnum, const char *format,...)$/;"	f
error_buffer	regexp_system.c	/^static char error_buffer[2048];$/;"	v	file:
error_state	jmp.c	53;"	d	file:
errsp0	test/mawktest.bat	/^:errsp0$/;"	l
errsp1	test/mawktest.bat	/^:errsp1$/;"	l
errsp2	test/mawktest.bat	/^:errsp2$/;"	l
errsp3	test/mawktest.bat	/^:errsp3$/;"	l
escape	rexp0.c	/^escape(char **start_p)$/;"	f	file:
eval_overflow	execute.c	/^eval_overflow(void)$/;"	f	file:
eval_stack	execute.c	/^CELL eval_stack[EVAL_STACK_SIZE];$/;"	v
eval_underflow	execute.c	/^eval_underflow(void)$/;"	f	file:
exception	test/fpe_test.bat	/^set exception=$/;"	v
exception	test/fpe_test.bat	/^set exception=0$/;"	v
exception	test/fpe_test.bat	/^set exception=1$/;"	v
execute	execute.c	/^execute(INST * cdp,		\/* code ptr, start execution here *\/$/;"	f
execution_start	code.c	/^INST *execution_start = 0;$/;"	v
exit_code	main.c	/^int exit_code;$/;"	v
exit_status	files.c	/^    int exit_status;$/;"	m	struct:child	file:
expr	parse.y	/^expr    :  expr IN  ID$/;"	l
expr	parse.y	/^expr    :  field   ASSIGN   expr { code1(F_ASSIGN) ; }$/;"	l
expr	parse.y	/^expr  :   cat_expr$/;"	l
f_arglist	parse.y	/^f_arglist  :  \/* empty *\/ { $$ = init_arglist() ; }$/;"	l
f_args	parse.y	/^f_args     :  ID$/;"	l
failed	test/mawktest.bat	/^:failed$/;"	l
fbank_free	field.c	/^fbank_free(CELL *const fb)$/;"	f	file:
fbankv	field.c	/^CELL **fbankv;$/;"	v
fbankv_free	field.c	/^fbankv_free(void)$/;"	f	file:
fbankv_num_chunks	field.c	/^static size_t fbankv_num_chunks;$/;"	v	file:
fblock	symtype.h	/^typedef struct fblock {$/;"	s
fbp	jmp.c	/^    FBLOCK *fbp;		\/* if scope FUNCT *\/$/;"	m	struct:mc	file:
fbp	parse.c	/^  FBLOCK   *fbp  ;   \/* ptr to a function block *\/$/;"	m	union:__anon9	file:
fbp	parse.h	/^  FBLOCK   *fbp  ;   \/* ptr to a function block *\/$/;"	m	union:__anon6
fbp	symtype.h	/^	FBLOCK *fbp;$/;"	m	union:__anon29::__anon30
fcall	symtype.h	/^typedef struct fcall {$/;"	s
fd	fin.h	/^    int fd;			\/* file-descriptor *\/$/;"	m	struct:__anon25
fdump	da.c	/^typedef struct fdump {$/;"	s	file:
fdump_list	da.c	/^static DUMP_FUNCS *fdump_list;	\/* linked list of all user functions *\/$/;"	v	file:
field	field.c	/^CELL field[FBANK_SZ + NUM_PFIELDS];$/;"	v
field	parse.y	/^field   :  FIELD$/;"	l
field_A2I	parse.c	/^field_A2I(void)$/;"	f	file:
field_addr_to_index	field.c	/^field_addr_to_index(CELL *cp)$/;"	f
field_assign	field.c	/^field_assign(CELL *fp, CELL *cp)$/;"	f
field_init	field.c	/^field_init(void)$/;"	f
field_leaks	field.c	/^field_leaks(void)$/;"	f
field_ptr	field.h	55;"	d
file	files.c	/^typedef struct file {$/;"	s	file:
file_close	files.c	/^file_close(STRING * sval)$/;"	f
file_find	files.c	/^file_find(STRING * sval, int type)$/;"	f
file_flush	files.c	/^file_flush(STRING * sval)$/;"	f
file_list	files.c	/^static FILE_NODE *file_list;$/;"	v	file:
files_leaks	files.c	/^files_leaks(void)$/;"	f
fillbuff	fin.c	/^fillbuff(int fd, char *target, size_t size)$/;"	f
fin_leaks	fin.c	/^fin_leaks(void)$/;"	f
find	hash.c	/^find(const char *s)$/;"	f
find_bi_name	da.c	/^find_bi_name(PF_CP p)$/;"	f	file:
find_by_ival	array.c	/^static ANODE* find_by_ival($/;"	f	file:
find_by_sval	array.c	/^static ANODE* find_by_sval($/;"	f	file:
find_kw_str	kw.c	/^find_kw_str(int kw_token)$/;"	f
finish_ptr	zmalloc.c	/^finish_ptr(PTR ptr, size_t size)$/;"	f	file:
first	rexp0.c	/^    int first;$/;"	m	struct:__anon20	file:
first_pass	fcall.c	/^first_pass(FCALL_REC * p)$/;"	f	file:
flags	fin.h	/^    int flags;$/;"	m	struct:__anon25
flush_all_output	files.c	/^flush_all_output(void)$/;"	f
fname	init.h	/^    char *fname;$/;"	m	struct:pfile
for1	parse.y	/^for1    :  FOR LPAREN  SEMI_COLON   { $$ = code_offset ; }$/;"	l
for2	parse.y	/^for2    :  SEMI_COLON   { $$ = code_offset ; }$/;"	l
for3	parse.y	/^for3    :  RPAREN$/;"	l
fp	fin.h	/^    FILE *fp;			\/* NULL unless interactive *\/$/;"	m	struct:__anon25
fp	parse.c	/^  PF_CP    fp ;      \/* ptr to a (print\/printf) or (sub\/gsub) function *\/$/;"	m	union:__anon9	file:
fp	parse.h	/^  PF_CP    fp ;      \/* ptr to a (print\/printf) or (sub\/gsub) function *\/$/;"	m	union:__anon6
fp	symtype.h	/^	PF_CP fp;$/;"	m	union:__anon29::__anon30
fp	symtype.h	/^    PF_CP fp;			\/* ptr to function that does the builtin *\/$/;"	m	struct:__anon26
fpcheck	matherr.c	/^fpcheck(void)$/;"	f
fpe_catch	fpe_check.c	/^fpe_catch(FPE_ARGS)$/;"	f	file:
fpe_catch	matherr.c	/^fpe_catch(FPE_ARGS)$/;"	f	file:
fpe_init	matherr.c	/^fpe_init(void)$/;"	f
fplib_err	bi_funct.c	/^fplib_err($/;"	f	file:
free_STRING	memory.h	42;"	d
free_STRING	memory.h	46;"	d
free_arglist	parse.c	/^free_arglist(void)$/;"	f	file:
free_cell_data	code.c	/^free_cell_data(CELL *cp)$/;"	f
free_codes	code.c	/^free_codes(const char *tag, INST * base, size_t size)$/;"	f
free_codes	mawk.h	248;"	d
free_filenode	files.c	/^free_filenode(FILE_NODE * p)$/;"	f	file:
free_fin_data	fin.c	/^free_fin_data(FIN * fin)$/;"	f	file:
free_hashnode	hash.c	/^free_hashnode(HASHNODE * p)$/;"	f	file:
free_hashnode	hash.c	80;"	d	file:
free_name	symtype.h	/^    char free_name;$/;"	m	struct:__anon29
free_ptr_data	zmalloc.c	/^free_ptr_data(void *a)$/;"	f	file:
free_symtab_name	hash.c	/^free_symtab_name(HASHNODE * p)$/;"	f	file:
fs_shadow	field.c	/^CELL fs_shadow =$/;"	v
funct_head	parse.y	/^funct_head    :  FUNCTION  ID$/;"	l
funct_start	parse.y	/^funct_start   :  funct_head  LPAREN  f_arglist  RPAREN$/;"	l
function_def	parse.y	/^function_def  :  funct_start  block$/;"	l
fvalue	parse.y	/^fvalue  :   lvalue  |  field  ;$/;"	l
get_cclass	rexp0.c	/^get_cclass(char *start, char **next)$/;"	f	file:
get_fpe_codes	fpe_check.c	/^get_fpe_codes(void)$/;"	f	file:
get_pipe	files.c	/^get_pipe(char *name, int type, int *pid_ptr)$/;"	f
get_pipe	msdos/dosexec.c	/^get_pipe(char *command,$/;"	f
get_shell	msdos/dosexec.c	/^get_shell(void)$/;"	f	file:
getline	parse.y	/^getline :   GETLINE  { getline_flag = 1 ; } ;$/;"	l
getline_file	parse.y	/^getline_file  :  getline  IO_IN$/;"	l
getline_flag	scan.c	/^int getline_flag;		\/* changes meaning of '<' *\/$/;"	v
gobble	examples/decl.awk	/^function gobble(s,  x)  $/;"	f
gobble	examples/gdecl.awk	/^function gobble(s,  x)  $/;"	f
grow_sp_list	split.c	/^grow_sp_list(Split_Block_Node * tail)$/;"	f	file:
gsub3	bi_funct.c	/^gsub3(PTR re, CELL *repl, CELL *target)$/;"	f	file:
hash	hash.c	/^hash(const char *s)$/;"	f
hash	hash.c	/^typedef struct hash {$/;"	s	file:
hash2	hash.c	/^hash2(const char *s, size_t len)$/;"	f
hash_leaks	hash.c	/^hash_leaks(void)$/;"	f
hash_table	hash.c	/^static HASHNODE *hash_table[HASH_PRIME];$/;"	v	file:
haveValue	init.c	/^haveValue(char *value)$/;"	f	file:
hex	scan.c	/^hex(char **start_p)$/;"	f	file:
hex_val	rexp0.c	/^static char hex_val['f' - 'A' + 1] =$/;"	v	file:
hex_val	scan.c	/^static const char hex_val['f' - 'A' + 1] =$/;"	v	file:
hex_value	scan.c	829;"	d	file:
hexdec	msdos/examples/winexe.awk	/^function hexdec (x) {$/;"	f
hexdec	msdos/examples/winobj.awk	/^function hexdec (x) {$/;"	f
hmask	array.h	/^   unsigned hmask ; \/* bitwise and with hash value to get table index *\/$/;"	m	struct:array
hmask_to_limit	array.c	50;"	d	file:
hval	array.c	/^   unsigned hval ;$/;"	m	struct:anode	file:
if_front	parse.y	/^if_front :  IF LPAREN expr RPAREN$/;"	l
ignore_star_star	rexp1.c	/^ignore_star_star(MACHINE * mp)$/;"	f	file:
ignore_unused	main.c	/^int ignore_unused;$/;"	v
ilink	array.c	/^   struct anode  *ilink ;$/;"	m	struct:anode	typeref:struct:anode::anode	file:
ilink	array.c	/^typedef struct {struct anode *slink, *ilink ;} DUAL_LINK ;$/;"	m	struct:__anon22	typeref:struct:__anon22::	file:
improve_arglist	parse.c	/^improve_arglist(const char *name)$/;"	f	file:
inc_sp	execute.c	39;"	d	file:
infnan	matherr.c	/^infnan(int arg)$/;"	f
init_arglist	parse.c	/^init_arglist(void)$/;"	f	file:
initial_seed	bi_funct.c	/^initial_seed(void)$/;"	f	file:
initialize	init.c	/^initialize(int argc, char **argv)$/;"	f
inpipe_exit	files.c	/^    int inpipe_exit;$/;"	m	struct:file	file:
insert	hash.c	/^insert(const char *s)$/;"	f
interactive_flag	init.c	/^short interactive_flag = 0;$/;"	v
invalid_format	field.c	/^invalid_format(CELL *fp)$/;"	f	file:
isAnchored	repl.h	40;"	d
isEmpty_RE	repl.h	41;"	d
is_array	symtype.h	82;"	d
is_cmdline_assign	fin.c	/^is_cmdline_assign(char *s)$/;"	f
is_empty	repl.h	/^    int is_empty;		\/* check if pattern is empty *\/$/;"	m	struct:re_data
is_local	symtype.h	83;"	d
is_nan	fpe_check.c	/^is_nan(double d)$/;"	f	file:
is_string_split	rexp4.c	/^is_string_split(PTR q, SLen * lenp)$/;"	f
isblank	rexp0.c	351;"	d	file:
ishex	scan.c	831;"	d	file:
isoctal	rexp0.c	751;"	d	file:
isoctal	scan.c	827;"	d	file:
ison	rexp.h	105;"	d
isort	examples/qsort.awk	/^function  isort(A , n,    i, j, hold)$/;"	f
ival	array.c	/^   Int     ival ;$/;"	m	struct:anode	file:
ival	parse.c	/^  int      ival ;$/;"	m	union:__anon9	file:
ival	parse.h	/^  int      ival ;$/;"	m	union:__anon6
jbuff	fpe_check.c	/^jmp_buf jbuff;$/;"	v
jfmt	da.c	/^static const char *jfmt = "%s%s%03d\\n";$/;"	v	file:
jmp	jmp.c	/^typedef struct jmp {$/;"	s	file:
jmp_top	jmp.c	/^static JMP *jmp_top;$/;"	v	file:
jump	rexp.h	/^	int jump;$/;"	m	union:__anon14::__anon15
keywords	kw.c	/^keywords[] =$/;"	v	typeref:struct:kw	file:
kw	kw.c	/^    short kw;$/;"	m	struct:kw	file:
kw	kw.c	/^static const struct kw$/;"	s	file:
kw	symtype.h	/^	int kw;$/;"	m	union:__anon29::__anon30
kw_init	kw.c	/^kw_init(void)$/;"	f
l_base	parse.c	/^    YYSTYPE  *l_base;$/;"	m	struct:__anon10	file:
l_mark	parse.c	/^    YYSTYPE  *l_mark;$/;"	m	struct:__anon10	file:
last	rexp0.c	/^    int last;$/;"	m	struct:__anon20	file:
last_hash	hash.c	/^static unsigned last_hash;$/;"	v	file:
last_used_regexp	regexp_system.c	/^static mawk_re_t *last_used_regexp = NULL;$/;"	v	file:
len	jmp.c	/^    unsigned len;		\/* its length *\/$/;"	m	struct:mc	file:
len	types.h	/^    size_t len;$/;"	m	struct:__anon12
limit	array.h	/^   size_t limit ; \/* Meaning depends on type *\/$/;"	m	struct:array
limit	code.h	/^    INST *base, *limit, *warn, *ptr;$/;"	m	struct:__anon23
limit	execute.c	/^    STRING **limit;$/;"	m	struct:aloop_state	file:
limit	fin.h	/^    char *limit;		\/* points past the data in *buff *\/$/;"	m	struct:__anon25
lineno	scan.c	/^static unsigned lineno = 1;$/;"	v	file:
link	da.c	/^    struct fdump *link;$/;"	m	struct:fdump	typeref:struct:fdump::fdump	file:
link	da.c	/^    struct regex *link;$/;"	m	struct:regex	typeref:struct:regex::regex	file:
link	execute.c	/^    struct aloop_state *link;$/;"	m	struct:aloop_state	typeref:struct:aloop_state::aloop_state	file:
link	field.h	/^    struct spov *link;$/;"	m	struct:spov	typeref:struct:spov::spov
link	files.c	/^    struct child *link;$/;"	m	struct:child	typeref:struct:child::child	file:
link	files.c	/^    struct file *link;$/;"	m	struct:file	typeref:struct:file::file	file:
link	hash.c	/^    struct hash *link;$/;"	m	struct:hash	typeref:struct:hash::hash	file:
link	init.h	/^    struct pfile *link;$/;"	m	struct:pfile	typeref:struct:pfile::pfile
link	jmp.c	/^    struct bc *link;		\/* stack as linked list *\/$/;"	m	struct:bc	typeref:struct:bc::bc	file:
link	jmp.c	/^    struct jmp *link;$/;"	m	struct:jmp	typeref:struct:jmp::jmp	file:
link	jmp.c	/^    struct mc *link;$/;"	m	struct:mc	typeref:struct:mc::mc	file:
link	re_cmpl.c	/^    struct re_node *link;$/;"	m	struct:re_node	typeref:struct:re_node::re_node	file:
link	re_cmpl.c	/^    struct repl_node *link;$/;"	m	struct:repl_node	typeref:struct:repl_node::repl_node	file:
link	split.c	/^    struct split_block *link;$/;"	m	struct:split_block	typeref:struct:split_block::split_block	file:
link	symtype.h	/^    struct ca_rec *link;$/;"	m	struct:ca_rec	typeref:struct:ca_rec::ca_rec
link	symtype.h	/^    struct fcall *link;$/;"	m	struct:fcall	typeref:struct:fcall::fcall
link	zmalloc.c	/^    union zblock *link;$/;"	m	union:zblock	typeref:union:zblock::zblock	file:
literal_leftsq	rexp0.c	/^literal_leftsq(char *start)$/;"	f	file:
load_environ	init.c	/^load_environ(ARRAY ENV)$/;"	f
load_pfield	field.c	/^load_pfield(const char *name, CELL *cp)$/;"	f	file:
log	configure	/^log ();$/;"	f
longstr	fpe_check.c	/^char longstr[] =$/;"	v
lookup_cclass	rexp0.c	/^lookup_cclass(char **start)$/;"	f	file:
lp	rexp0.c	/^static char *lp;		\/*  ptr to reg exp string  *\/$/;"	v	file:
lvalue	parse.y	/^lvalue  :  ID mark LBOX  args  RBOX$/;"	l
lvalue	parse.y	/^lvalue :  ID$/;"	l
m	re_cmpl.c	/^    PTR m;$/;"	m	struct:_all_ptrs	file:
m	rexp.h	/^    STATE *m;			\/* save the machine ptr *\/$/;"	m	struct:__anon17
main	config.guess	/^		main()$/;"	f
main	config.guess	/^	main ()$/;"	f
main	config.guess	/^main ()$/;"	f
main	fpe_check.c	/^main(int argc, char *argv[])$/;"	f
main	main.c	/^main(int argc, char **argv)$/;"	f
main	makescan.c	/^main(void)$/;"	f
main_code_p	code.c	/^CODEBLOCK *main_code_p, *begin_code_p, *end_code_p;$/;"	v
main_fin	fin.c	/^FIN *main_fin;$/;"	v
main_size	code.c	/^size_t begin_size, main_size, end_size;$/;"	v
main_start	code.c	/^INST *begin_start, *main_start, *end_start;$/;"	v
make_empty_table	array.c	/^static void make_empty_table($/;"	f	file:
make_sfmt	print.c	/^make_sfmt(const char *format,$/;"	f	file:
mark	parse.y	/^mark : \/* empty *\/$/;"	l
matherr	matherr.c	/^matherr(struct exception *e)$/;"	f
mawk_exit	main.c	/^mawk_exit(int x)$/;"	f
mawk_re_t	regexp_system.c	/^} mawk_re_t;$/;"	t	typeref:struct:__anon5	file:
mawk_state	main.c	/^short mawk_state;		\/* 0 is compiling *\/$/;"	v
mawkid	msdos/dosexec.c	/^static unsigned mawkid;		\/* unique to this mawk process *\/$/;"	v	file:
max_args	symtype.h	/^    unsigned char min_args, max_args;$/;"	m	struct:__anon26
max_field	field.c	/^static int max_field = FBANK_SZ - 1;$/;"	v	file:
may_be_safe_to_look_at_why	fpe_check.c	/^int may_be_safe_to_look_at_why = 0;$/;"	v
mc	jmp.c	/^typedef struct mc {		\/* mc -- move code *\/$/;"	s	file:
mc_top	jmp.c	/^static MC *mc_top;$/;"	v	file:
message	fpe_check.c	/^message(const char *s)$/;"	f	file:
middle	examples/qsort.awk	/^function middle(x,y,z)  #return middle of 3$/;"	f
min_args	symtype.h	/^    unsigned char min_args, max_args;$/;"	m	struct:__anon26
missing	error.c	/^missing(int c, const char *n, unsigned ln)$/;"	f	file:
missing_rbrace	error.c	/^static const int missing_rbrace[] =$/;"	v	file:
missing_rparen	error.c	/^static const int missing_rparen[] =$/;"	v	file:
move_level	jmp.c	/^    int move_level;		\/* size of this stack when coded *\/$/;"	m	struct:mc	file:
move_level	symtype.h	/^    short move_level;$/;"	m	struct:fcall
mpow2	cast.c	/^const int mpow2[NUM_CELL_TYPES] =$/;"	v
my_shell	msdos/dosexec.c	/^static char *my_shell;		\/* e.g.   "c:\\\\sys\\\\command.com"  *\/$/;"	v	file:
name	da.c	/^    const char *name;$/;"	m	struct:__anon2	file:
name	da.c	/^   const char *name ;$/;"	m	struct:__anon3	file:
name	files.c	/^    STRING *name;$/;"	m	struct:file	file:
name	symtype.h	/^    const char *name;$/;"	m	struct:__anon26
name	symtype.h	/^    const char *name;$/;"	m	struct:__anon29
name	symtype.h	/^    const char *name;$/;"	m	struct:fblock
nargs	symtype.h	/^    unsigned short nargs;$/;"	m	struct:fblock
nbuffs	fin.h	/^    unsigned nbuffs;		\/* sizeof *buff in BUFFSZs *\/$/;"	m	struct:__anon25
nest	rexp0.c	/^static size_t nest;$/;"	v	file:
new_ARRAY	array.h	44;"	d
new_STRING	memory.c	/^new_STRING(const char *s)$/;"	f
new_STRING0	memory.c	/^new_STRING0(size_t len)$/;"	f
new_STRING1	memory.c	/^new_STRING1(const char *s, size_t len)$/;"	f
new_TWO	rexp1.c	/^new_TWO($/;"	f	file:
new_code	code.c	/^new_code(void)$/;"	f	file:
next	cast.c	/^    struct _all_cells *next;$/;"	m	struct:_all_cells	typeref:struct:_all_cells::_all_cells	file:
next	init.c	/^    struct _all_arrays *next;$/;"	m	struct:_all_arrays	typeref:struct:_all_arrays::_all_arrays	file:
next	re_cmpl.c	/^    struct _all_ptrs *next;$/;"	m	struct:_all_ptrs	typeref:struct:_all_ptrs::_all_ptrs	file:
next	scan.h	52;"	d
next_label	execute.c	/^INST *next_label;$/;"	v
next_main	fin.c	/^next_main(int open_flag)	\/* called by open_main() if on *\/$/;"	f	file:
next_tmp	msdos/dosexec.c	/^static int next_tmp;		\/* index for naming temp files *\/$/;"	v	file:
nf	field.c	/^int nf;$/;"	v
no_leaks_array	init.c	/^no_leaks_array(ARRAY a)$/;"	f
no_leaks_array	symtype.h	158;"	d
no_leaks_cell	cast.c	/^no_leaks_cell(CELL *cp)$/;"	f
no_leaks_cell	mawk.h	249;"	d
no_leaks_cell_ptr	cast.c	/^no_leaks_cell_ptr(CELL *cp)$/;"	f
no_leaks_cell_ptr	mawk.h	250;"	d
no_leaks_re_ptr	mawk.h	251;"	d
no_leaks_re_ptr	re_cmpl.c	/^no_leaks_re_ptr(PTR m)$/;"	f
no_program	init.c	/^no_program(void)$/;"	f	file:
null_split	split.c	/^null_split(const char *s, size_t slen)$/;"	f
null_str	memory.c	/^STRING null_str =$/;"	v
num_word	test/wfrq0.awk	/^function num_word(num, word)$/;"	f
octal	scan.c	/^octal(char **start_p)$/;"	f	file:
offset	jmp.c	/^    int offset;			\/* distance from its code base *\/$/;"	m	struct:mc	file:
offset	symtype.h	/^    unsigned char offset;	\/* offset in stack frame for local vars *\/$/;"	m	struct:__anon29
ok_abbrev	init.c	/^ok_abbrev(const char *fullName, const char *partName, int partLen)$/;"	f	file:
okay1	test/fpe_test.bat	/^:okay1$/;"	l
okay2	test/fpe_test.bat	/^:okay2$/;"	l
okay3	test/fpe_test.bat	/^:okay3$/;"	l
op	da.c	/^    char op;$/;"	m	struct:__anon2	file:
op	types.h	/^    int op;$/;"	m	union:__anon13
open_main	fin.c	/^open_main(void)$/;"	f
other_codes	da.c	/^static const OP_NAME other_codes[] = {$/;"	v	file:
out_of_mem	zmalloc.c	/^out_of_mem(void)$/;"	f	file:
output_failed	files.c	/^output_failed(const char *name)$/;"	f	file:
outside_error	parse.y	/^outside_error :  error$/;"	l
overflow	error.c	/^overflow(const char *s, unsigned size)$/;"	f
overflow	fpe_check.c	/^overflow(double x)$/;"	f	file:
owner	rexp.h	/^    int owner;$/;"	m	struct:__anon18
p_expr	parse.y	/^p_expr   :  field   %prec CAT \/* removes field (++|--) sr conflict *\/$/;"	l
p_expr	parse.y	/^p_expr  :   DOUBLE$/;"	l
p_expr	parse.y	/^p_expr  :   RE$/;"	l
p_expr	parse.y	/^p_expr  :   p_expr  PLUS   p_expr { code1(_ADD) ; }$/;"	l
p_expr	parse.y	/^p_expr  :   split_front  split_back$/;"	l
p_expr	parse.y	/^p_expr  :  FUNCT_ID mark  call_args$/;"	l
p_expr	parse.y	/^p_expr  :  ID  INC_or_DEC$/;"	l
p_expr	parse.y	/^p_expr  :  ID mark LBOX  args  RBOX   %prec  AND$/;"	l
p_expr	parse.y	/^p_expr  :  field  INC_or_DEC$/;"	l
p_expr	parse.y	/^p_expr  :  sub_or_gsub LPAREN re_arg COMMA  expr  sub_back$/;"	l
p_expr	parse.y	/^p_expr :  getline      %prec  GETLINE$/;"	l
p_expr	parse.y	/^p_expr : MATCH_FUNC LPAREN expr COMMA re_arg RPAREN$/;"	l
paren_cnt	scan.c	/^int paren_cnt;$/;"	v
parse	parse.c	/^parse(void)$/;"	f
parse_w_opt	init.c	/^parse_w_opt(char *source, char **next)$/;"	f	file:
patch_jmp	jmp.c	/^patch_jmp(INST * target)$/;"	f
pfile	init.h	/^typedef struct pfile {$/;"	s
pfile_list	scan.c	/^PFILE *pfile_list;$/;"	v
pfile_name	scan.c	/^char *pfile_name;$/;"	v
pid	files.c	/^    int pid;			\/* we need to wait() when we close a pipe *\/$/;"	m	struct:file	file:
pid	files.c	/^    int pid;$/;"	m	struct:child	file:
pool	zmalloc.c	/^static ZBLOCK *pool[POOLSZ];$/;"	v	file:
pos	rexp.h	/^    const char *pos;$/;"	m	struct:__anon18
posix_space_flag	init.c	/^short posix_space_flag;$/;"	v
pr_args	parse.y	/^pr_args :  arglist { code2op(_PUSHINT, $1) ; }$/;"	l
pr_direction	parse.y	/^pr_direction : \/* empty *\/$/;"	l
prepare_regexp	regexp_system.c	/^prepare_regexp(char *regexp, const char *source, size_t limit)$/;"	f	file:
prev	rexp0.c	/^static int prev;$/;"	v	file:
prev_offset	rexp.h	/^    int prev_offset;$/;"	m	struct:__anon18
print	parse.y	/^print   :  PRINT  { $$ = bi_print ; print_flag = 1 ;}$/;"	l
print_cell	print.c	/^print_cell(CELL *p, FILE *fp)$/;"	f	file:
print_flag	scan.c	/^int print_flag;			\/* changes meaning of '>' *\/$/;"	v
print_version	version.c	/^print_version(void)$/;"	f
process_cmdline	init.c	/^process_cmdline(int argc, char **argv)$/;"	f	file:
progname	init.c	/^const char *progname;$/;"	v
program	parse.y	/^program :       program_block$/;"	l
program_block	parse.y	/^program_block :  PA_block   \/* pattern-action *\/$/;"	l
program_fd	scan.c	/^static int program_fd;$/;"	v	file:
program_string	scan.c	/^static STRING *program_string;$/;"	v	file:
ptr	array.h	/^   PTR ptr ;  \/* What this points to depends on the type *\/$/;"	m	struct:array
ptr	cast.c	/^    char ptr;$/;"	m	struct:_all_cells	file:
ptr	code.h	/^    INST *base, *limit, *warn, *ptr;$/;"	m	struct:__anon23
ptr	execute.c	/^    STRING **ptr;$/;"	m	struct:aloop_state	file:
ptr	field.h	/^    PTR ptr;			\/* STRING* or RE machine* *\/$/;"	m	struct:__anon4
ptr	files.c	/^    PTR ptr;			\/* FIN*   or  FILE*   *\/$/;"	m	struct:file	file:
ptr	parse.c	/^  PTR      ptr ;$/;"	m	union:__anon9	file:
ptr	parse.h	/^  PTR      ptr ;$/;"	m	union:__anon6
ptr	types.h	/^    PTR ptr;$/;"	m	struct:cell
ptr	types.h	/^    PTR ptr;$/;"	m	union:__anon13
ptr	zmalloc.c	/^    PTR ptr;$/;"	m	struct:__anon19	file:
ptr_data	zmalloc.c	/^static void *ptr_data;$/;"	v	file:
ptr_to	examples/decl.awk	/^function ptr_to(n,  x)  # print "pointer to" , n times$/;"	f
ptr_to	examples/gdecl.awk	/^function ptr_to(n,  x)  # print "pointer to" , n times$/;"	f
push	rexp2.c	143;"	d	file:
push	rexp2.c	147;"	d	file:
push	rexp2.c	395;"	d	file:
push	rexp3.c	22;"	d	file:
push	rexp3.c	441;"	d	file:
puts_sfmt	print.c	/^puts_sfmt(PTR target,$/;"	f	file:
qsort	examples/qsort.awk	/^function  qsort(A, left, right    ,i , j, pivot, hold)$/;"	f
re	re_cmpl.c	/^    RE_DATA re;			\/* keep this first, for re_destroy() *\/$/;"	m	struct:re_node	file:
re	regexp_system.c	/^    regex_t re;$/;"	m	struct:__anon5	file:
re_arg	parse.y	/^re_arg   :   expr$/;"	l
re_compile	re_cmpl.c	/^re_compile(STRING * sval)$/;"	f
re_data	repl.h	/^typedef struct re_data {$/;"	s
re_destroy	re_cmpl.c	/^re_destroy(PTR m)$/;"	f
re_leaks	re_cmpl.c	/^re_leaks(void)$/;"	f
re_len	rexp0.c	/^static size_t re_len;$/;"	v	file:
re_list	re_cmpl.c	/^static RE_NODE *re_list;$/;"	v	file:
re_node	re_cmpl.c	/^typedef struct re_node {$/;"	s	file:
re_pos_match	split.c	/^re_pos_match(char *str, size_t str_len, PTR re, size_t *lenp, int no_bol)$/;"	f
re_split	split.c	/^re_split(char *s, size_t slen, PTR re)$/;"	f
re_str	rexp0.c	/^static char *re_str;		\/*  base of 'lp' *\/$/;"	v	file:
re_uncompile	re_cmpl.c	/^re_uncompile(PTR m)$/;"	f
record_ptr	zmalloc.c	/^record_ptr(PTR ptr, size_t size)$/;"	f	file:
refRE_DATA	repl.h	43;"	d
ref_cnt	types.h	/^    unsigned ref_cnt;$/;"	m	struct:__anon12
regcomp	configure	/^regcomp ();$/;"	f
regex	da.c	/^typedef struct regex {$/;"	s	file:
regex_list	da.c	/^static DUMP_REGEX *regex_list;	\/* list regular expressions dumped *\/$/;"	v	file:
regexp	regexp_system.c	/^    char *regexp;$/;"	m	struct:__anon5	file:
relocate_arglist	fcall.c	/^relocate_arglist($/;"	f	file:
relocate_resolve_list	fcall.c	/^relocate_resolve_list($/;"	f
remove_from_child_list	files.c	/^remove_from_child_list(int pid)$/;"	f	file:
repl_cnt	bi_funct.c	/^static unsigned repl_cnt;	\/* number of global replacements *\/$/;"	v	file:
repl_compile	re_cmpl.c	/^repl_compile(STRING * sval)$/;"	f
repl_destroy	re_cmpl.c	/^repl_destroy(CELL *cp)$/;"	f
repl_list	re_cmpl.c	/^static REPL_NODE *repl_list;$/;"	v	file:
repl_node	re_cmpl.c	/^typedef struct repl_node {$/;"	s	file:
repl_uncompile	re_cmpl.c	/^repl_uncompile(CELL *cp)$/;"	f
replv_cpy	re_cmpl.c	/^replv_cpy(CELL *target, CELL *source)$/;"	f
replv_to_repl	re_cmpl.c	/^replv_to_repl(CELL *cp, STRING * sval)$/;"	f
reset_argv	msdos/examples/add_cr.awk	/^function reset_argv(T, i, j, flag, file) #all args local$/;"	f
resize_fblock	parse.c	/^resize_fblock(FBLOCK * fbp)$/;"	f	file:
resolve_fcalls	fcall.c	/^resolve_fcalls(void)$/;"	f
resolve_list	fcall.c	/^FCALL_REC *resolve_list;$/;"	v
restart_label	execute.c	/^static INST *restart_label;	\/* control flow labels *\/$/;"	v	file:
restore_ids	hash.c	/^restore_ids(void)$/;"	f
ret1	test/fpe_test.bat	/^set ret1=$/;"	v
ret1	test/fpe_test.bat	/^set ret1=0$/;"	v
ret1	test/fpe_test.bat	/^set ret1=1$/;"	v
ret1	test/fpe_test.bat	/^set ret1=128$/;"	v
ret1	test/fpe_test.bat	/^set ret1=2$/;"	v
ret1	test/fpe_test.bat	/^set ret1=3$/;"	v
ret2	test/fpe_test.bat	/^set ret2=$/;"	v
ret2	test/fpe_test.bat	/^set ret2=0$/;"	v
ret2	test/fpe_test.bat	/^set ret2=1$/;"	v
ret2	test/fpe_test.bat	/^set ret2=128$/;"	v
ret2	test/fpe_test.bat	/^set ret2=2$/;"	v
ret2	test/fpe_test.bat	/^set ret2=3$/;"	v
ret3	test/fpe_test.bat	/^set ret3=$/;"	v
ret3	test/fpe_test.bat	/^set ret3=0$/;"	v
ret3	test/fpe_test.bat	/^set ret3=1$/;"	v
ret3	test/fpe_test.bat	/^set ret3=128$/;"	v
ret3	test/fpe_test.bat	/^set ret3=2$/;"	v
ret3	test/fpe_test.bat	/^set ret3=3$/;"	v
return_CELL	bi_funct.c	45;"	d	file:
return_CELL	bi_funct.c	49;"	d	file:
return_statement	parse.y	/^return_statement :  RETURN   separator$/;"	l
reverse_find	hash.c	/^reverse_find(int type, PTR ptr)$/;"	f
rexp_leaks	regexp.c	/^rexp_leaks(void)$/;"	f
rm_escape	scan.c	/^rm_escape(char *s, size_t *lenp)$/;"	f
rs_shadow	field.c	/^SEPARATOR rs_shadow =$/;"	v
rt_error	error.c	/^rt_error(const char *format,...)$/;"	f
rt_fnr	error.c	/^unsigned rt_nr, rt_fnr;$/;"	v
rt_nr	error.c	/^unsigned rt_nr, rt_fnr;$/;"	v
rt_overflow	error.c	/^rt_overflow(const char *s, unsigned size)$/;"	f
rt_where	error.c	/^rt_where(void)$/;"	f	file:
s	rexp.h	/^    char *s;			\/* save the active string ptr *\/$/;"	m	struct:__anon17
s_base	parse.c	/^    YYINT    *s_base;$/;"	m	struct:__anon10	file:
s_data	rexp.h	/^    } s_data;$/;"	m	struct:__anon14	typeref:union:__anon14::__anon15
s_last	parse.c	/^    YYINT    *s_last;$/;"	m	struct:__anon10	file:
s_len	rexp.h	/^    SLen s_len;			\/* used for M_STR  *\/$/;"	m	struct:__anon14
s_mark	parse.c	/^    YYINT    *s_mark;$/;"	m	struct:__anon10	file:
s_type	rexp.h	/^    SType s_type;$/;"	m	struct:__anon14
same	test/fpe_test.bat	/^set same=$/;"	v
same	test/fpe_test.bat	/^set same=0$/;"	v
same	test/fpe_test.bat	/^set same=1$/;"	v
same12	test/fpe_test.bat	/^:same12$/;"	l
same123	test/fpe_test.bat	/^:same123$/;"	l
same23	test/fpe_test.bat	/^:same23$/;"	l
save_arglist	parse.c	/^save_arglist(const char *s)$/;"	f	file:
save_id	hash.c	/^save_id(const char *s)$/;"	f
save_list	hash.c	/^static HASHNODE *save_list;$/;"	v	file:
scan_cleanup	scan.c	/^scan_cleanup(void)$/;"	f
scan_code	makescan.c	/^char scan_code[256];$/;"	v
scan_fillbuff	scan.c	/^scan_fillbuff(void)$/;"	f	file:
scan_init	makescan.c	/^scan_init(void)$/;"	f	file:
scan_init	scan.c	/^scan_init(const char *cmdline_program)$/;"	f
scan_leaks	scan.c	/^scan_leaks(void)$/;"	f
scan_open	scan.c	/^scan_open(void)			\/* open pfile_name *\/$/;"	f	file:
scan_print	makescan.c	/^scan_print(void)$/;"	f	file:
scope	jmp.c	/^    int scope;			\/* its scope *\/$/;"	m	struct:mc	file:
scope	parse.c	/^static int scope;$/;"	v	file:
seed	bi_funct.c	/^static long seed;		\/* must be >=1 and < 2^31-1 *\/$/;"	v	file:
separator	parse.y	/^separator  :  NL | SEMI_COLON$/;"	l
set_ARGV	init.c	/^set_ARGV(int argc, char **argv, int i)$/;"	f	file:
set_binmode	field.c	/^set_binmode(int x)$/;"	f
set_cc_for_build	config.guess	/^set_cc_for_build() {$/;"	f
set_code	code.c	/^set_code(void)$/;"	f
set_field0	field.c	/^set_field0(char *s, size_t len)$/;"	f
set_main_to_stdin	fin.c	/^set_main_to_stdin(void)$/;"	f	file:
set_rs_shadow	field.c	/^set_rs_shadow(void)$/;"	f	file:
set_stdio	files.c	/^set_stdio(void)$/;"	f
sfmtMINUS	print.c	/^    sfmtMINUS = 2,$/;"	e	enum:__anon8	file:
sfmtPREC	print.c	/^    sfmtPREC = 16$/;"	e	enum:__anon8	file:
sfmtSPACE	print.c	/^    sfmtSPACE = 1,$/;"	e	enum:__anon8	file:
sfmtWIDTH	print.c	/^    sfmtWIDTH = 8,$/;"	e	enum:__anon8	file:
sfmtZEROS	print.c	/^    sfmtZEROS = 4,$/;"	e	enum:__anon8	file:
shell	files.c	/^const char *shell = "\/bin\/sh";$/;"	v
simple_code	da.c	/^static const OP_NAME simple_code[] =$/;"	v	file:
size	array.h	/^   size_t size ; \/* number of elts in the table *\/$/;"	m	struct:array
size	symtype.h	/^    size_t size;$/;"	m	struct:fblock
size	zmalloc.c	/^    size_t size;$/;"	m	struct:__anon19	file:
size_t	nstd.h	/^typedef unsigned size_t;$/;"	t
skipValue	init.c	/^skipValue(char *value)$/;"	f	file:
slink	array.c	/^   struct anode *slink ;$/;"	m	struct:anode	typeref:struct:anode::anode	file:
slink	array.c	/^typedef struct {struct anode *slink, *ilink ;} DUAL_LINK ;$/;"	m	struct:__anon22	typeref:struct:__anon22::anode	file:
slow_cell_assign	field.c	/^slow_cell_assign(CELL *target, CELL *source)$/;"	f
slow_field_ptr	field.c	/^slow_field_ptr(int i)$/;"	f
slow_next	scan.c	/^slow_next(void)$/;"	f	file:
slow_push	rexp2.c	/^slow_push($/;"	f	file:
source_offset	jmp.c	/^    int source_offset;		\/* position of _JMP  *\/$/;"	m	struct:bc	file:
source_offset	jmp.c	/^    int source_offset;$/;"	m	struct:jmp	file:
sp	rexp.h	/^    int sp;			\/* size of position stack *\/$/;"	m	struct:__anon17
space_split	split.c	/^space_split(const char *s, size_t slen)$/;"	f
spb_list_shrink	split.c	/^spb_list_shrink(void)$/;"	f	file:
special_cases	da.c	/^special_cases[] =$/;"	v	typeref:struct:__anon3	file:
split_back	parse.y	/^split_back  :   RPAREN$/;"	l
split_block	split.c	/^typedef struct split_block {$/;"	s	file:
split_block_base	split.c	/^static Split_Block_Node split_block_base;$/;"	v	file:
split_block_list	split.c	/^static Split_Block_Node *split_block_list = &split_block_base;$/;"	v	file:
split_buff	re_cmpl.c	/^static STRING *split_buff[MAX_SPLIT];$/;"	v	file:
split_field0	field.c	/^split_field0(void)$/;"	f
split_front	parse.y	/^split_front : SPLIT LPAREN expr COMMA ID$/;"	l
spov	field.h	/^typedef struct spov {$/;"	s
sprintf_buff	print.c	/^char *sprintf_buff = string_buff;$/;"	v
sprintf_limit	print.c	/^char *sprintf_limit = string_buff + sizeof(string_buff);$/;"	v
ss	rexp.h	/^    char *ss;			\/* save the match start -- only used by REmatch *\/$/;"	m	struct:__anon17
stack_base	execute.c	/^static CELL *stack_base = eval_stack;$/;"	v	file:
stack_danger	execute.c	/^static CELL *stack_danger = eval_stack + DANGER;$/;"	v	file:
stacksize	parse.c	/^    unsigned stacksize;$/;"	m	struct:__anon10	file:
start	parse.c	/^  int      start ;   \/* code starting address as offset from code_base *\/$/;"	m	union:__anon9	file:
start	parse.h	/^  int      start ;   \/* code starting address as offset from code_base *\/$/;"	m	union:__anon6
start	rexp.h	/^    STATE *start, *stop;$/;"	m	struct:__anon16
start	symtype.h	/^    int start;			\/* offset to code_base *\/$/;"	m	struct:__anon27
statement	parse.y	/^statement      :  EXIT   separator$/;"	l
statement	parse.y	/^statement   :   for1 for2 for3 statement$/;"	l
statement	parse.y	/^statement  :    while_front  statement$/;"	l
statement	parse.y	/^statement  :  array_loop_front  statement$/;"	l
statement	parse.y	/^statement :  DELETE  ID mark LBOX args RBOX separator$/;"	l
statement	parse.y	/^statement :  block$/;"	l
statement	parse.y	/^statement :  if_front statement else statement$/;"	l
statement	parse.y	/^statement :  print mark pr_args pr_direction separator$/;"	l
statement	parse.y	/^statement : do statement WHILE LPAREN expr RPAREN separator$/;"	l
statement	parse.y	/^statement : if_front statement$/;"	l
statement_list	parse.y	/^statement_list :  statement$/;"	l
stdout_init	files.c	/^stdout_init(void)$/;"	f
stop	rexp.h	/^    STATE *start, *stop;$/;"	m	struct:__anon16
store_bvp	rexp0.c	/^store_bvp(BV * bvp)$/;"	f	file:
stp	parse.c	/^  SYMTAB   *stp ;$/;"	m	union:__anon9	file:
stp	parse.h	/^  SYMTAB   *stp ;$/;"	m	union:__anon6
str	error.c	/^    const char *str;$/;"	m	struct:token_str	file:
str	rexp.h	/^	char *str;		\/* string *\/$/;"	m	union:__anon14::__anon15
str	types.h	/^    char str[2];$/;"	m	struct:__anon12
str_str	bi_funct.c	/^str_str(char *target, size_t target_len, const char *key, size_t key_len)$/;"	f
string	mawk.h	106;"	d
string_buff	scan.c	/^char string_buff[SPRINTF_LIMIT];$/;"	v
string_compare	array.c	/^static int string_compare($/;"	f	file:
string_too_long	scan.c	/^string_too_long(void)$/;"	f	file:
strings	split.c	/^    STRING *strings[SP_SIZE];$/;"	m	struct:split_block	file:
strtod	matherr.c	296;"	d	file:
strtod	mawk.h	172;"	d
strtod_with_ovf_bug	matherr.c	/^strtod_with_ovf_bug(const char *s, char **ep)$/;"	f
stval	symtype.h	/^    } stval;$/;"	m	struct:__anon29	typeref:union:__anon29::__anon30
sub_back	parse.y	/^sub_back    :   RPAREN    \/* substitute into $0  *\/$/;"	l
sub_or_gsub	parse.y	/^sub_or_gsub :  SUB  { $$ = bi_sub ; }$/;"	l
sval	array.c	/^   STRING *sval ;$/;"	m	struct:anode	file:
sval	field.h	/^    STRING *sval;$/;"	m	struct:spov
sval	re_cmpl.c	/^    STRING *sval;		\/* the input *\/$/;"	m	struct:repl_node	file:
sval	re_cmpl.c	/^    STRING *sval;$/;"	m	struct:re_node	file:
switch_code_to_main	parse.c	/^switch_code_to_main(void)$/;"	f	file:
sym_p	symtype.h	/^    SYMTAB *sym_p;		\/* if type is ST_NONE  *\/$/;"	m	struct:ca_rec
symtab	hash.c	/^    SYMTAB symtab;$/;"	m	struct:hash	file:
tab2	da.c	/^static const char *tab2 = "\\t\\t";$/;"	v	file:
table	rexp.c	/^static  short  table[8][8] = {$/;"	v	file:
tc	execute.c	/^static CELL tc;			\/*useful temp *\/$/;"	v	file:
test	execute.c	/^test(CELL *cp)$/;"	f
test1_1	test/fpe_test.bat	/^:test1_1$/;"	l
test1_128	test/fpe_test.bat	/^:test1_128$/;"	l
test1_2	test/fpe_test.bat	/^:test1_2$/;"	l
test1_3	test/fpe_test.bat	/^:test1_3$/;"	l
test1_ret	scan.h	55;"	d
test2	test/fpe_test.bat	/^:test2$/;"	l
test2_1	test/fpe_test.bat	/^:test2_1$/;"	l
test2_128	test/fpe_test.bat	/^:test2_128$/;"	l
test2_2	test/fpe_test.bat	/^:test2_2$/;"	l
test2_3	test/fpe_test.bat	/^:test2_3$/;"	l
test2_ret	scan.h	58;"	d
test3	test/fpe_test.bat	/^:test3$/;"	l
test3_1	test/fpe_test.bat	/^:test3_1$/;"	l
test3_128	test/fpe_test.bat	/^:test3_128$/;"	l
test3_2	test/fpe_test.bat	/^:test3_2$/;"	l
test3_3	test/fpe_test.bat	/^:test3_3$/;"	l
text	kw.c	/^    const char *text;$/;"	m	struct:kw	file:
tfopen	files.c	/^tfopen(const char *name, const char *mode)$/;"	f	file:
tmp_file_name	msdos/dosexec.c	/^tmp_file_name(int id,$/;"	f
tmpdir	msdos/dosexec.c	/^static char *tmpdir;		\/* directory to hold temp files *\/$/;"	v	file:
token	error.c	/^    short token;$/;"	m	struct:token_str	file:
token_lineno	scan.c	/^unsigned token_lineno;$/;"	v
token_name	rexp.c	/^token_name(int token)$/;"	f	file:
token_str	error.c	/^static const struct token_str {$/;"	s	file:
token_str	error.c	/^} token_str[] = {$/;"	v	typeref:struct:token_str	file:
tp	rexp.h	/^    int tp;			\/* offset to top entry of position stack *\/$/;"	m	struct:__anon17
trace_arg_list	fcall.c	/^trace_arg_list(CA_REC * arg_list)$/;"	f	file:
trace_arg_list	fcall.c	44;"	d	file:
trace_fp	trace.c	/^static FILE *trace_fp;$/;"	v	file:
trace_leaks	trace.c	/^trace_leaks(void)$/;"	f
transfer_to_array	split.c	/^transfer_to_array(CELL cp[], size_t cnt)$/;"	f
transfer_to_fields	split.c	/^transfer_to_fields(size_t cnt)$/;"	f
type	array.h	/^   short type ;  \/* values in AY_NULL .. AY_SPLIT *\/$/;"	m	struct:array
type	field.h	/^    char type;$/;"	m	struct:__anon4
type	files.c	/^    short type;$/;"	m	struct:file	file:
type	jmp.c	/^    int type;			\/* 'B' or 'C' or mark start with 0 *\/$/;"	m	struct:bc	file:
type	symtype.h	/^    char type;$/;"	m	struct:__anon29
type	symtype.h	/^    short type;$/;"	m	struct:ca_rec
type	types.h	/^    short type;$/;"	m	struct:cell
type3	test/fpe_test.bat	/^:type3$/;"	l
type_error	error.c	/^type_error(SYMTAB * p)$/;"	f
type_names	da.c	/^static const OP_NAME type_names[] =$/;"	v	file:
type_p	symtype.h	/^    char *type_p;		\/* if type  is ST_LOCAL_NONE *\/$/;"	m	struct:ca_rec
type_to_str	error.c	/^type_to_str(int type)$/;"	f
typev	symtype.h	/^    char *typev;		\/* array of size nargs holding types *\/$/;"	m	struct:fblock
u	rexp.h	/^    int u;			\/* save the u_flag *\/$/;"	m	struct:__anon17
un_next	scan.h	53;"	d
unexpected_char	error.c	/^unexpected_char(void)$/;"	f
usage	examples/primes.awk	/^function usage()$/;"	f
usage	init.c	/^usage(void)$/;"	f	file:
valid_format	field.c	/^valid_format(CELL *fp)$/;"	f	file:
var	execute.c	/^    CELL *var;			\/* for(var in A) *\/$/;"	m	struct:aloop_state	file:
vcnt	types.h	/^    VCount vcnt;		\/* only used if type == C_REPLV   *\/$/;"	m	struct:cell
wait_for	files.c	/^wait_for(int pid)$/;"	f
wait_status	files.c	/^wait_status(int status)$/;"	f
warn	code.h	/^    INST *base, *limit, *warn, *ptr;$/;"	m	struct:__anon23
while_front	parse.y	/^while_front :  WHILE LPAREN expr RPAREN$/;"	l
why_v	fpe_check.c	/^int why_v;$/;"	v
working_mask	matherr.c	/^static fp_except working_mask;$/;"	v	file:
write_error	print.c	/^write_error(void)$/;"	f	file:
xcode2	code.c	/^xcode2(int op, PTR ptr)$/;"	f
xlat	rexpdb.c	/^static const char *xlat[] =$/;"	v	file:
xnew_STRING	memory.c	/^xnew_STRING(size_t len)$/;"	f	file:
yychar	parse.c	/^int      yychar;$/;"	v
yycheck	parse.c	/^static const YYINT yycheck[] = {                          7,$/;"	v	file:
yyclearin	parse.c	11;"	d	file:
yydebug	parse.c	/^int      yydebug;$/;"	v
yydefred	parse.c	/^static const YYINT yydefred[] = {                         0,$/;"	v	file:
yydgoto	parse.c	/^static const YYINT yydgoto[] = {                         25,$/;"	v	file:
yyerrflag	parse.c	/^int      yyerrflag;$/;"	v
yyerrok	parse.c	12;"	d	file:
yyerror	error.c	/^yyerror(const char *s GCC_UNUSED)$/;"	f
yyfreestack	parse.c	/^static void yyfreestack(YYSTACKDATA *data)$/;"	f	file:
yyfreestack	parse.c	1581;"	d	file:
yygindex	parse.c	/^static const YYINT yygindex[] = {                         0,$/;"	v	file:
yygrowstack	parse.c	/^static int yygrowstack(YYSTACKDATA *data)$/;"	f	file:
yylen	parse.c	/^static const YYINT yylen[] = {                            2,$/;"	v	file:
yylex	scan.c	/^yylex(void)$/;"	f
yylhs	parse.c	/^static const YYINT yylhs[] = {                           -1,$/;"	v	file:
yylval	parse.c	/^YYSTYPE  yylval;$/;"	v
yyname	parse.c	/^static const char *const yyname[] = {$/;"	v	file:
yynerrs	parse.c	/^int      yynerrs;$/;"	v
yyrindex	parse.c	/^static const YYINT yyrindex[] = {                         0,$/;"	v	file:
yyrule	parse.c	/^static const char *const yyrule[] = {$/;"	v	file:
yysindex	parse.c	/^static const YYINT yysindex[] = {                       -73,$/;"	v	file:
yystack	parse.c	/^static YYSTACKDATA yystack;$/;"	v	file:
yytable	parse.c	/^static const YYINT yytable[] = {                         79,$/;"	v	file:
yyval	parse.c	/^YYSTYPE  yyval;$/;"	v
zblock	zmalloc.c	/^typedef union zblock {$/;"	u	file:
zfree	zmalloc.c	/^zfree(PTR p, size_t size)$/;"	f
zmalloc	zmalloc.c	/^zmalloc(size_t size)$/;"	f
zmalloc_leaks	zmalloc.c	/^zmalloc_leaks(void)$/;"	f
zrealloc	zmalloc.c	/^zrealloc(PTR p, size_t old_size, size_t new_size)$/;"	f

/* after ctags output

So that's great and all, but it's too much for a human to conveniently read.

As a human what I would do next is start looking at main, and trace the dependencies from there.

So we have two directions: one is from the top of the file down, which we can roughly fix up as a dependency tree with the root at the bottom, the other is from the main function up, along all the call edges until we are satisfied that we understand enough.

*/
